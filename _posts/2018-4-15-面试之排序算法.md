---
layout: post
title:  "面试之排序算法"
date:  2018-4-15 23:01:12
categories: algorithm
tags: 算法

---
* content
{:toc}







## 前言

排序大的分类可以分为两种：内排序和外排序。在排序过程中，全部记录存放在内存，则称为内排序，如果排序过程中需要使用外存，则称为外排序。下面讲的排序都是属于内排序。

1. 插入排序：直接插入排序、二分法插入排序、希尔排序。
2. 选择排序：简单选择排序、堆排序。
3. 交换排序：冒泡排序、快速排序。
4. 归并排序
5. 基数排序

## 参考文章

- [http://eddy.wiki/interview-algorithm.html](http://eddy.wiki/interview-algorithm.html)
- [http://www.cnblogs.com/liuling/p/2013-7-24-01.html](http://www.cnblogs.com/liuling/p/2013-7-24-01.html)
- [排序算法过程演示动画](http://www.atool.org/sort.php)








![](https://i.imgur.com/erXsr7o.png)




## 1、冒泡排序

- **(1)基本思想**： 冒泡排序是一种简单的排序算法。两两比较相邻记录的关键字，如果他们的顺序错误就把他们交换过来。也就是说，让较大的数往下沉，较小的往上冒。

- **(2)分析算法**：除非手边没有算法书可参照，一般情况很少用冒泡排序算法；当数据量很小的时候它会有价值外，其余都不建议使用。
	- 冒泡排序是一种稳定的排序方法。
	- 若文件初状为正序，则一趟起泡就可完成排序，排序码的比较次数为 n-1，且没有记录移动，时间复杂度是 O(n)；
	- 若文件初态为逆序，则需要 n-1 趟冒泡，每趟进行 n-i 次排序码的比较，比较和移动次数均达到最大值∶O(n^2)；
	- 冒泡排序平均时间复杂度为：O(n^2)；

- **(3)代码实现(java)**：
```java
public static void main(String[] args) {
    int[] nums = {3, 1, 7, 5, 8, 9, 23, 45};
    for (int i = 0; i < nums.length; i++) {
        //这里的-i是将排好序的就不参加进来
        for (int j = 0; j < nums.length - 1 - i; j++) {
            if (nums[j] > nums[j + 1]) {// 如果前面大于后面，则互换
                int temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
}
```











## 2、选择排序

- **(1)基本思想**：选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下：
	- 首先找出数组中最小的那个元素，将它和数组的第一个元素交换位置。
	- 在剩下的元素中继续找最小的元素，将它与数组的第二个元素交换位置。
	- 如此往复，直到将整个数组排序。

- **(2)分析算法**：虽然把**交换次数**降到了最低，但**比较次数**仍比较大。当数据量很小，并且交换数据相对比较数据更加耗时的情况下，可以使用选择排序。
	- 简单选择排序是不稳定的排序。
	- 时间复杂度：T(n)=O(n^2)；

- **(3)运行过程**：通过 n-i 次关键字间的比较，从 n-i+1 个记录中选出关键字最小的记录，并和第 i 个记录交互。

> 找到最小值 0 与 当前 i = 0 相交互。N=0
> 
> **6** 3 5 7 **0** 4 1 2     
> 
> **0** 3 5 7 **6** 4 1 2  
> 
> 找到最小值 1 与 当前 i = 1 相交互。N=1
> 
> 0 **3** 5 7 6 4 **1** 2       
> 
> 0 **1** 5 7 6 4 **3** 2 
> 
> 找到最小值 1 与 当前 i = 1 相交互。N=2
> 
> 0 1 **5** 7 6 4 3 **2**        
> 
> 0 1 **2** 7 6 4 3 **5**
> 
> . . .

- **(4)代码实现(java)**：
```java
public static void main(String[] args) {
    int[] num = {99, 57, 2, 45, 65, 33, 12};
    int min;
    for (int i = 0; i < num.length; i++) {
        min = i;// 将当前下标定义为最小值下标
        for (int j = i + 1; j < num.length; j++) { // 循环比较
            if (num[min] > num[j]) {               // 相邻的两个数字,找到最小的
                min = j;                           // 将此关键字的下标赋值给min
            }
        }
        if (i != min) {                // 若min不等于i，说明找到最小值，进行交换
            int temp = num[i];
            num[i] = num[min];
            num[min] = temp;
        }
    }
    for (int i : num) {
        System.out.print(i + " ");
    }
}
```










## 3、插入排序

- **(1)基本思想**：插入排序( Straight Insertion Sort ) 是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。
	1. 先把当前 nums[i] 的值传给第三方空间 insertNote。
	2. 判断 insertNote 是否小于 nums[ j ]， nums[ j ] 是 nums[ i ] 前一个数，j=i-1。
	3. 如果是小于，将 j 的值放到 j+1 值里面去，也就是当前 i 的位置。同时 j - -，再往前找。
	4. 如果 insertNote 仍然小于上上家 j-2， 将 j-2 的值放到之前 j-1 值里面去，j - -。

- **(2)分析算法**：
	- 当数据量比较小或基本有序时，插入排序算法是三种排序中最好的选择。
	- 适用于少量数据的排序，
	- 插入排序是一个稳定的排序方法。

- **(3)分类**：
	- 直接插入排序
	- 二分插入排序

### 3.1直接插入排序：

- **(4)基本思想**：把待排序的纪录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的纪录插入完为止，得到一个新的有序序列。

- **(5)效率分析**：
	- 空间复杂度O(1)；
	- 平均复杂度O(n^2);
	- 最差情况：反序，需要移动 n*(n-1)/2 个元素 ，运行时间为 O(n^2)。
	- 最好情况：正序，不需要移动元素，运行时间为 O(n)。

- **(6)代码实现(Java)**：
```java
public static void main(String[] args) {
    int num[] = {6, 5, 3, 1, 8, 7, 2, 4};
    int i, j, insertNote;// 要插入的数据
    for (i = 1; i < num.length; i++) {// 从数组的第二个元素开始循环将数组中的元素插入
        insertNote = num[i];// 设置数组中的第2个元素为第一次循环要插入的数据
        j = i - 1;// 前一个元素
        while (j >= 0 && insertNote < num[j]) {
            num[j + 1] = num[j];// 如果要插入的元素小于第j个元素,就将第j个元素向后移动
            j--;
        }
        num[j + 1] = insertNote;// 直到要插入的元素不小于第j个元素,将insertNote插入到数组中
    }
    for (int k : num) {
        System.out.print(k + " ");
    }
}
```

### 3.2二分插入排序：

- **(7)基本思想**直接插入排序中要把插入元素与已有序序列元素依次进行比较，效率非常低。折半插入排序，使用折半查找的方式寻找插入点的位置，可以减少比较的次数,但移动的次数不变，时间复杂度和空间复杂度和直接插入排序一样，在元素较多的情况下能提高查找性能。

- **(8)代码实现**：
```java
private static void binaryInsertSort(int[] a)  {  
		//从数组的第二个位置开始遍历值	
        for(int i = 1; i < a.length; i++)  {  
            int key = a[i];           //暂存要插入的值    
            int pre = 0;              //有序序列开始和结尾下标申明
            int last = i - 1;       
        // 折半查找出插入位置 a[pre]
            while(pre <= last)  {  
                int mid = (pre + last) / 2;                
                if(key < a[mid])  {  
                	last = mid - 1;  
                } else {  
                	pre = mid + 1;  
                }  
            }  
     //a[i]已经取出来存放在key中，把下标从pre + 1到 i-1的元素依次后移
            for(int j = i; j >= pre + 1; j--)  {  
                a[j] = a[j - 1];  
            }  
            //把值插入空白位置
            a[pre] = key;            
        }  
    } 
```

- **(9)插入小结**：
	- 直接插入排序是，比较一个后移一个； 
	- 折半插入排序是，先找到位置，然后一起移动；






## 4、归并排序

- **(1)基本思想**：该算法是采用分治算法（Divide and Conquer），各层分治递归可以同时进行，把一个数组分成两半，排序每一半，然后用merge()方法把数组的两半并成一个有序的数组。

- **(2)具体过程**：
	1. 通过不断的递归 mergeSort() 方法，每一次这个方法调用自身的时候，排列都会被分成两半。把每个一半都分成两个四分之一，再分成两个一半八分之一、十六分之一以此类推反复分割数组。
	2. 当 mergeSort() 方法发现两个只有 1 个数据项的数组时，它就返回，把 2 个数据项归并到一个只有 2 个数据项的有序数组中。每生成一对 2 个数据项的数组又被合并成一个有 4 个数据项的有序数组。这个过程一直持续下去，数组越来越大直到数组有序。
	3. 总之，先拆后拼。

- **(3)缺点**：归并排序需要在存储器中有另一个大小等于被排序的数据项数目的数组，如果初始数组几乎沾满整个存储器，那么归并排序将不能工作。但是有足够空间，归并排序会是一个很好的选择。

- **(4)前提例子**：归并两个有序的数组：2018腾讯校招例子

> 设数组 A 有 4 个数据项，数组 B 有 6 个数据项，它们要被归并到数组 C 中。
> 
> 数组 A：23，47，81 ，95
> 
> 数组 B：7，14 ，39 ，55 ，62 ，74

- **(5)代码实现**：
```java
public static void main(String[] args) {
    int[] a = {23, 47, 81, 95};
    int[] b = {7, 14, 39, 55, 62, 74};
    int[] c = new int[a.length + b.length];
    // 归并排序（数组a、数组a的长度、数组b、数组b的长度、数组C）
    merge(a, 4, b, 6, c);
    for (int k = 0; k < c.length; k++) {
        System.out.print(c[k] + " ");
    }
}
private static void merge(int[] a, int i, int[] b, int j, int[] c) {
    int adex = 0, bdex = 0, cdex = 0;// 索引
    // 当i和j小于数组的长度，循环将小的放进数组
    while (adex < i && bdex < j)
        if (a[adex] < b[bdex])
            c[cdex++] = a[adex++];
        else
            c[cdex++] = b[bdex++];
    // 当B数组的数据项已经全部移出了
    while (adex < i)
        c[cdex++] = a[adex++];
    // 当A数组的数据项已经全部移出了
    while (bdex < j)
        c[cdex++] = b[bdex++];
    }
```

- **(6)性能分析**：
	- 归并排序速度仅次于快速排序；
	- 是一种稳定排序算法；
	- 时间复杂度为O(nlogn)； 
	- 空间复杂度为 O(n)；
	- 归并排序比较占用内存，但却是效率高且稳定的算法。

- **(7)代码实现(java)**：
	1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
	2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
	3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
	4. 重复 步骤3 直到某一指针到达序列尾
	5. 将另一序列剩下的所有元素直接复制到合并序列尾

```java
    public static void main(String[] args) {

        int nums[] = {51, 30, 90, 10, 70, 40, 80, 60, 20};
        MergeSort(nums, 0, nums.length - 1);
        System.out.println("排序结果：" + Arrays.toString(nums));
    }

    private static void MergeSort(int[] nums, int start, int end) {
        int middle = (start + end) / 2;  //计算中间位置
        if (start < end) {
            MergeSort(nums, start, middle);  // 对左边数据集在拆分
            MergeSort(nums, middle + 1, end);  // 对右边数据集在拆分
            merge(nums, start, middle, end);   // 归并两个有序的部分
        }
    }

    public static void merge(int[] a, int start, int mid, int end) {
        int[] temp = new int[end - start + 1];
        int i = start;// 左指针
        int j = mid + 1;// 右指针
        int k = 0;
        // 把较小的数先移到新数组中，i--->mid，j--->max
        while (i <= mid && j <= end) {
            if (a[i] < a[j]) {
                temp[k++] = a[i++];
            } else {
                temp[k++] = a[j++];
            }
        }
        // 把左边剩余的数移入数组
        while (i <= mid) {
            temp[k++] = a[i++];
        }
        // 把右边边剩余的数移入数组
        while (j <= end) {
            temp[k++] = a[j++];
        }
        // 把新数组中的数覆盖nums数组
        for (int k2 = 0; k2 < temp.length; k2++) {
            a[k2 + start] = temp[k2];
        }
    }
```
















## 5、快速排序

- **(1)概述**：快速排序（Quicksort）是对冒泡排序的一种改进，又称划分交换排序（partition-exchange sort）。采用了分治法策略，把一个序列（list）分为两个子序列（sub-lists）。

- **(2)基本思想**：
	- 在一个数组中取一个基准数字，把小的数放基准的左边，大的数放基准的右边。
	- 在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
	- 基准左边和右边分别是新的序列，在新的序列中再取一个基准数字，小的放左边，大的放右边。

![](https://i.imgur.com/buuWIjs.gif)

- **(3)性能分析**：在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。
	- 最差时间复杂度	Ο(n^2)　
	- 最优时间复杂度	Ο(n log n)　
	- 平均时间复杂度Ο(n log n)　
	- 最差空间复杂度	根据实现的方式不同而不同

- **(4)代码实现**：
```java
public static void main(String[] args) {
    int[] nums = {4, 2, 5, 3, 0, 1, 7};
    QSort(nums, 0, nums.length - 1);
    System.out.print(Arrays.toString(nums));
}
private static void QSort(int[] nums, int left, int right) {
    if (left < right) {
        int pivot = Partition(nums, left, right); // 算出枢轴值
        QSort(nums, left, pivot - 1); // 对低子表递归排序
        QSort(nums, pivot + 1, right); // 对高子表递归排序
    }
}
private static int Partition(int[] nums, int left, int right) {
    int p = nums[left];// 取第一位数作为枢轴值
    while (left < right) {
        while (left < right && nums[right] >= p)
            right--;
        swap(nums, left, right);
        while (left < right && nums[left] <= p)
            left++;
        swap(nums, left, right);
    }
    return left;
}
public static void swap(int[] nums, int left, int right) {
    int temp = nums[left];
    nums[left] = nums[right];
    nums[right] = temp;
}
```
















## 6、堆排序

- **(1)基本概念**：堆排序是一种树形选择排序，是对直接选择排序的有效改进。
	- **大顶堆**：每个结点的值都大于或等于其左右孩子结点的值。
	- **小顶堆**：每个结点的值都小于或等于其左右孩子结点的值。

- **(2)基本思想**：就是利用大顶堆进行排序的方法。将待排序的序列构成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将它与堆数组的末尾元素交换，此时末尾元素就是最大值。然后将剩余的n-1个序列重新构成一个堆，这样就会得到n个元素中的次小值。如此反复，便能得到一个有序序列。

- **(3)性能分析**：
	- 堆排序也是一种不稳定的排序算法。
	- 堆排序优于简单选择排序的原因：直接选择排序中，为了从R[1..n]中选出关键字最小的记录，必须进行n-1次比较，然后在R[2..n]中选出关键字最小的记录，又需要做n-2次比较。事实上，后面的n-2次比较中，有许多比较可能在前面的n-1次比较中已经做过，但由于前一趟排序时未保留这些比较结果，所以后一趟排序时又重复执行了这些比较操作。
	- 堆排序可通过树形结构保存部分比较结果，可减少比较次数。
	- 堆排序的最坏时间复杂度为O(nlogn)。
	- 堆序的平均性能较接近于最坏性能。由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。

![](https://i.imgur.com/0L5lphm.gif)

- **(4)代码实现(Java)**
```java
public static void main(String[] args) {
    int[] array = {22, 44, 0, 88, 11, 66, 55, 33, 99, 77
    Test1 heapsort = new Test1();
    heapsort.heapsort(array);
    for (int i = 0; i < array.length - 1; i++) {
        System.out.print(array[i] + " ");
    }
}
public void heapsort(int[] a) {
    if (a == null || a.length <= 1)
        return;
    buildBigHeap(a);// 创建大堆
    // 收集大堆顶0的数
    for (int i = a.length - 1; i >= 1; i--) {
        // 每次循环都把最大值a[0]的数和最后那个数交换
        swap(a, 0, i);
        // 替换完，还需要进行大堆的构造。
        maxHeap(a, i, 0);
    }
}
// 将最大数字挪上去堆顶，
// 由于完全二叉树第五性质，根节点为0，i的左右子树为i*2+1,i*2+2
private void buildBigHeap(int[] a) {
    int half = (a.length - 1) / 2;// 只需遍历一半,// 长度为10,只需要
    for (int i = half; i >= 0; i--) {
        maxHeap(a, a.length, i);
    }
}
// 数组、元素个数、开始节点
private void maxHeap(int[] a, int length, int i) {
    int left = i * 2 + 1;
    int right = i * 2 + 2;
    int largest = i;
    // 拿i的左右子树进行比较
    if (left < length && a[left] > a[i]) {
        largest = left;
    }
    if (right < length && a[right] > a[largest]) {
        largest = right;
    }
    if (i != largest) {
        // 交换数据
        swap(a, i, largest);
        // 继续往下大堆构造
        maxHeap(a, length, largest);
    }
}
private void swap(int[] a, int i, int largest) {
    int temp = a[i];
    a[i] = a[largest];
    a[largest] = temp;
}
```


















## 7、希尔排序

- **(1)概述**：希尔排序(Shell Sort) 属于插入类排序，而插入排序在记录本身就基本有序和少量操作的情况下工作效率才会高。那么希尔排序是将整个无序列分割成若干小的子序列分别进行插入排序的方法。

- **(2)基本思想**：
	- 先取一个正整数d1小于n，把所有序号相隔d1的数组元素放一组，组内进行直接插入排序；
	- 然后取d2小于d1，重复上述分组和排序操作；直至di=1，即所有记录放进一个组中排序为止。

- **(3)性能分析**：希尔排序是一个不稳定的排序，其时间复杂度受步长(增量)的影响。
	- 空间复杂度：Ｏ(1)
	- 时间复杂度：平均 O(n^1.3) ，最好O(n) ，最坏O(n^2)

![](https://i.imgur.com/YTvalbW.png)

- **(4)代码实现**：
```java
public static void main(String[] args) {
    int[] a = {49, 38, 65, 97, 76, 13, 2, 99, 21, 75, 81, 64};
    int d = a.length;
    while (true) {
        d = d / 2;// 步长6
        //x 0~5
        for (int x = 0; x < d; x++) {
            //i=0+6,i<12,i=12
            for (int i = x + d; i < a.length; i = i + d) {
                int temp = a[i];
                int j;
                for (j = i - d; j >= 0 && a[j] > temp; j -= d) {
                    a[j + d] = a[j];
                }
                a[j + d] = temp;
            }
        }
        if (d == 1) {
            break;
        }
    }
    for (int i = 0; i < a.length; i++) {
        System.out.print(a[i] + " ");
    }
}
```










## 迭代与递归的区别

- 迭代：
- 递归：
