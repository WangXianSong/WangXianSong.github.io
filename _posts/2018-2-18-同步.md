---
layout: post
title:  "多线程之线程同步的七种方式"
date:  2018-2-18 02:26:49
categories: Android
tags: 学习笔记

---
* content
{:toc}







## 前言

我们在上一篇学习了多线程编程的基础概念(传送门)，接下来就开始学习多线程中的同步的七种方式。

## 线程的同步

### 同步的简介

在多线程的应用中，两个或两个以上的线程需要共享对同一个数据的存取。如果两个线程存取相同的对象，并且每一个线程都调用了修改该对象的方法，这种情况通常会引发资源同步的问题。

### 问题的引出

通过卖票的例子来看看资源同步的问题：
```java
public class MyRunnable implements Runnable {
    private int ticket = 5; //票的数量
    @Override
    public void run() {
        //超出票数量的循环
        for (int i = 0; i < 100; i++) {
            if (ticket > 0) {
                try {
                    Thread.sleep(300); //加入延迟
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                Log.d("TAG", Thread.currentThread().getName() + "run: 卖票：ticket=" + ticket--);
            } else
                break;
        }
    }
}
```
然后在 MainActivity 中去启动线程：
```java
MyRunnable r1 = new MyRunnable();
Thread t1 = new Thread(r1, "代理1");
Thread t2 = new Thread(r1, "代理2");
Thread t3 = new Thread(r1, "代理3");
t1.start();
t2.start();
t3.start();
```
程序运行结果：
```
· · ·
代理3run: 卖票：ticket=2
代理1run: 卖票：ticket=1
代理2run: 卖票：ticket=0
代理3run: 卖票：ticket=-1
```
上面的代码中，判断票数是否大于0，如果是大于0就表示还有票卖。如果小于0就跳出循环。

**那么为什么会出现负数的问题？原因是：**

1.假设 ticket 剩余 2 张；
2.线程1取到了 ticket，然后 ticket 减1，ticket=1；
3.线程2取到了 ticket，执行权跳到线程3；
4.线程3取到了 ticket，然后 ticket 减1，ticket =0；
5.线程2接着剩余操作，ticket 减1，ticket =-1；
6.这样一来就会出现票数为负的情况。

### 使用同步解决

如果想要解决这样的问题，就必须使用同步，所谓同步就是指多个操作在同一个时间内只能由一个线程进行，其他线程都要等待此线程完成之后才可以继续执行。

Java线程同步的方式有：同步代码块、同步方法、volatile、重入锁、wait与notify、ThreadLocal和阻塞队列。


## 1.synchronized 同步代码块

synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。以下是具体代码：
```java
 public void method() 
      { 
            synchronized (同步对象){ 
              //需要同步的代码... 
            } 
      }
```
在使用同步代码块时必须指定一个需要同步的对象，但一般都将当前对象 (this) 设置成同步对象。接下来同样是用卖票的案例，代码如下：
```java
public class MySynchronized implements Runnable {
    private int ticket = 10;//票的总数量
    @Override
    public void run() {
        while (true) {
            synchronized (this) {
                if (ticket > 0) {
                    try {
                        Thread.sleep(300); //加入延迟
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    Log.d("TAG", Thread.currentThread().getName()
                            + "卖票：ticket=" + ticket--);
                } else
                    break;
            }
        }
    }
}
```
然后在 MainActivity 中去启动线程：
```java
 MySynchronized ms = new MySynchronized();
 Thread t1 = new Thread(ms, "代理1");
 Thread t2 = new Thread(ms, "代理2");
 Thread t3 = new Thread(ms, "代理3");
 t1.start();
 t2.start();
 t3.start();
```
程序运行结果：
```
· · ·
卖票：ticket=4
卖票：ticket=3
卖票：ticket=2
卖票：ticket=1
```
从程序运行的结果来看，经过将取值和修改值的操作进行了同步，所以不会再出现票数为负的情况。

## 2.同步方法
同步方法是使用 synchronized 关键字将一个方法声明成同步方法。具体方法如下：

```java
public class Mysynchorized implements Runnable{
	public void run() {
		 this.sale();
	}
	public synchronized void sale(){
		//...
	}
}
```
仍然是刚刚的那个例子：
```java
public class Mysynchorized2 implements Runnable {
    private int ticket = 10;//票的总数量

    @Override
    public void run() {
        while (true) {
            this.sale();
        }
    }
    public synchronized void sale() {
        if (ticket > 0) {
            try {
                Thread.sleep(300); //加入延迟
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            Log.d("TAG", Thread.currentThread().getName()
                    + "卖票：ticket=" + ticket--);
        }
    }
}
```
然后在 MainActivity 中去启动线程：
```java
Mysynchorized2 ms = new Mysynchorized2();
Thread t1 = new Thread(ms, "代理1");
Thread t2 = new Thread(ms, "代理2");
Thread t3 = new Thread(ms, "代理3");
t1.start();
t2.start();
t3.start();
```
结果与之前同步代码块同样的功能。

### 同步方法和同步代码块的区别：
1.同步方法使用的锁是固定的this(只需要一个同步的情况)
2.同步代码块使用的锁可以是任意对象。(需要多个同步时，必须通过锁来区分)
3.同步代码块较为常用。


## 3.volatile

### volatile 简介
volatile 是 Java 提供的一种轻量级的同步机制，同 synchronized 相比（synchronized 通常称为重量级锁）volatile 更轻量级，相比使用 synchronized 所带来的庞大开销。在学习 volatile 之前，先来了解JMM 和并发三大特性。
```java
public volatile int num = 0;
```
### Java 内存模型(JMM)
**Java 内存模型(Java Memory Model)** 描述了 Java 程序中各种变量 (共享变量) 的访问规则，以及在 Java 虚拟机(JVM)中将变量存储到内存和从内存中读取出变量这样的底层细节。

- 所有的变量都存储在主内存中。
- 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)。

![jmm](https://i.imgur.com/QjAuBAj.png)

两条规定：

- 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。
- 线程之间无法直接访问工作内存中的变量，传递需要通过主内存来完成。

### 并发编程中的3个特性
**可见性**：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

![可见性](https://i.imgur.com/txZiNkc.png)

**原子性**：对基本数据类型变量的读取和赋值操作都是原子性操作，即这些操作是不可被中断的，要么执行完毕，要么就不执行。
```java
x = 3;	//语句1
y = x;	//语句2
x++;	//语句3
//1. 在上面代码中，只有语句1是原子性操作，其他都不是。
//2. 一个语句包含有多个操作时，就不是原子性操作。
```
 **有序性**：即程序执行的顺序按照代码的先后顺序执行。synchronized 和 Lock 保证每个时刻是有一个线程执行同步代码，自然就保证了有序性。

### volatile关键字：

当一个共享变量被 volatile 修饰之后，就具备两个含义：

- 线程修改了变量的值时，变量的新值对其他线程是立即可见的(可见性)。
- 禁止使用指令重排序。

**重排序：**就是代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化。重排序分为三类：编译器优化重排序（编译器优化）、指令级并行重排序（处理器优化）、内存系统重排序（处理器优化）。
```java
int num1 = 1；   //第1行代码
int num2 =3；	//第2行代码
int sum = num1 +num2 ；	//第3行代码
```
- 单线程中，第 1、2 行的顺序可以重排，但第 3 行不能，重排序不会给单线程带来内存可见性问题。
- 多线程中，程序交错执行时，重排序可能会造成内存可见性问题。

### volatile 的特性：

- volatile 保证操作的**可见性**。
- volatile 保证单次读写操作，不保证连续操作**原子性**。

解决方案：

- 使用 synchronized 关键字，来防止多个线程同时执行一段代码。
- 使用 ReentrantLock；
- 使用 AtomicInterger；

### 正确使用 volatile 关键字：

在多线程中安全的使用 volatile，必须同时满足以下两个条件：

- **对变量的写操作不会依赖于当前值**（也就是不能是自增、自减等操作）。
- **该变量没有包含在具有其他变量的不变式中**（下界总是小于或等于上界）。

### volatile 使用场景：

- 状态标志
- 双重检查模式(DCL)

### 小结：
volatile 变量是一种非常简单但又非常脆弱的同步机制，可以使用 volatile 代替 synchronized 来简化代码，然而代码往往会比使用锁的代码更容易出错。所以在一般情况下，最好使用 synchronized。



## 4.ReentrantLock 重入锁

ReentrantLock 与 synchronized 同样可以保证可见性、原子性。

```java
Lock mLock = new ReentrantLock();
mLock.lock();
try{
//todo...将锁放入try..finally语句块中操作
}finally{
mLock.unlock(); //释放锁
}
```

## 5.阻塞队列 BlockingQueue 

**阻塞队列 (BlockingQueue)**是Java util.concurrent包下重要的数据结构，BlockingQueue提供了线程安全的队列访问方式：

当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于BlockingQueue实现的。

### BlockingQueue 的操作方法

BlockingQueue 具有 4 组不同的方法用于插入、移除以及元素检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下：

​|  | 抛异常        | 特定值    |  阻塞  | 超时 |
| :-----:   | :---:   | :---: | :----: |
| 插入        | add(e)  | offer(e) | put(e) | offer(e, time, unit) |
| 取走        | remove() | poll() | take() | poll(time, unit) |
| 检查        | element() | peek() |  |  |

### 四组不同的行为方式解释：

- 抛异常，抛出异常；
- 特定值，返回一个特殊值（ null或者false，取决于操作）；
- 阻塞，一直阻塞当前线程，直到操作成功；
- 超时，在放弃之前只有给定的最大时间限制；

### 插入数据方法介绍：
**add(e)**：如果 BlockingQueue 能容纳，则将指定的元素插入此队列，成功时返回true。
**offer(e)**：如果 BlockingQueue 能容纳，则返回true，否则返回false(本方法不阻塞当前执行方法的线程)。
**put(e)**：如果 BlockingQueue 没空间，则调用此方法的线程被阻断，直到有空间再继续。
**offer(e, time, unit)**：可以设定等待时间再去插入，超时返回失败。

### 取走数据方法介绍：
**remove()**：检索并删除此队列的头部。这种方法的区别poll仅在于，如果此队列为空，则会引发异常。
**poll()**：检索并删除此队列的头部，若不能立即取走，则返回null。
**take()**：检索并删除此队列的头部，若 BlockingQueue 为空，则阻断进入等待状态，直到 BlockingQueue 有新的数据进入。
**poll(time, unit)**：检索并删除此队列的头部，在指定时间内，队列里一旦有数据可取，则返回队列中的数据；否则知道超时返回失败。
**drainTo()**：一次性从 BlockingQueue 取走所有数据对象(还可以指定个数)。

### BlockingQueue 的实现类

**ArrayBlockingQueue**：它是由数组实现的有界阻塞队列，并按照先进先出（FIFO）的原则元素进行排序。可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注：因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。

```java
ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(2000,true);
```
**LinkedBlockingQueue**：它是基于链表的可选有界阻塞队列，如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。

**DelayQueue**：它是一个支持延时获取元素的无界阻塞队列。创建元素时，可以指定元素到期的时间。

**PriorityBlockingQueue**：它是一个支持优先级的无界队列，默认采用自然顺序升序排列，同时可以Comparable 自定义。

**SynchronousQueue**：它是一个不存储元素的阻塞队列，每个插入操作都在等待另一个线程的移除操作，同样每个移除操作都在等待另一个线程的插入操作。



## 6.wait()与notify()

1.在 Java 中的 Object 类型都是带有一个内存锁的，在有线程获取该内存锁后，其它线程无法访问该内存，从而实现 Java 中简单的同步、互斥操作。 

2.同时 wait() 与 notify() 都是 Object 的子类，而且 Owait() 与 Obj.notify() 必须要与 synchronized(Obj)一起使用，也就是 wait 与 notify 是针对已经获取了 Obj 锁的对象来进行操作。

3.**wait() **就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的 notify() 唤醒该线程，才能继续获取对象锁，并继续执行。相应的 notify() 就是对对象锁的唤醒操作。 

4.**notify() **调用后，并不是马上就释放对象锁的，而是在相应的 synchronized(){} 语句块执行结束，自动释放锁后，JVM会在 wait() 对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。要是** notifyAll() **就会释放所有的锁。

简单代码格式：
```java
Object obj = newObject();
    synchronized(obj){
    try{　　
        obj.wait();
    }catch(Exception e){ }
        obj.notify();
　}
```
## 7.ThreadLocal

**ThreadLocal**：作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。简单来说，即多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据。

| 方法名 | 作用 |
| :---:   | --- |
| get() | 返回此线程局部变量 |
| set(T) | 将此线程局部变量设置为指定的值 |
| remove() | 删除此线程局部变量的当前线程值 |
| initialValue() | 返回此线程局部变量的当前线程的 "初始值" | 

### ThreadLocal工作原理
![threadlocad](https://i.imgur.com/qUYSJrN.png)

- 当我们调用 ThreadLocal 变量 set 方法时，通过hash后存储在Thread的ThreadLocalMap中，其中的Key为ThreadLocal对象，value为该对象在本线程中的一个副本。

- 当我们调用 get 方法时，会去 Thread 的 threadLocals 中去寻找 key为ThreadLocal 变量的值。



## 结束语

今天听了李健唱的一首歌 《父亲写的散文诗》，里面有两段内容让我思绪突然陷了进去，当我再听完整首歌的时候眼睛已经泛起泪光。

>一九八四年 庄稼还没收割完

>儿子躺在我怀里 睡得那么甜

>今晚的露天电影 没时间去看

>妻子提醒我 修修缝纫机的踏板

>明天我要去 邻居家再借点钱

>孩子哭了一整天啊 闹着要吃饼干

>蓝色的涤卡上衣 痛往心里钻

>蹲在池塘边上狠狠给了自己两拳

虽然我未曾做过父亲的这一角色，但从诗中可以看出，工作已经那么忙了，回到家还没好好休息，却因为生活苦恼着。我自己在生活里面常常因为钱而烦恼，所以在这里也特别有身同感受。

刚刚是以父亲的角度去看，现在我们站在儿子的角度。因为我们都为人子女，我们的父母总是不求回报的的给予我们。反而我有时候还闹腾要这要哪，却不懂生活之艰辛，哪怕现在我依然有和我父亲顶嘴冲撞的时候。

>想一想未来

>我老成了一堆旧纸钱

>那时的儿子已是真正的男子汉

>有个可爱的姑娘 和他成了家

>但愿他们不要活的如此艰难

在这一段中，父亲想着未来，自己的儿子也要成家立室，希望孩子日子过得更好。代表着父亲仍要不断地工作化身为大把大把钞票。突然戳中千万父母心，生了个娃还得供他读书，买车买房娶媳妇。

在不久的将来，我也要经历同样的问题，只是不希望一辈辈人留下的足迹任凭风雨抹去，作为我们更应该珍惜和感恩。



## 附录：参考资料

- 《Java 开发实战经典》李兴华
- 《Android进阶之光》刘望舒
- 慕课网 细说 Java 多线程之内存可见性：[https://www.imooc.com/video/6775](https://www.imooc.com/video/6775)
- 阻塞队列的实现原理：[http://blog.csdn.net/chenchaofuck1/article/details/51660119](http://blog.csdn.net/chenchaofuck1/article/details/51660119 "http://blog.csdn.net/chenchaofuck1/article/details/51660119")
- Java中的ThreadLocal对象：[http://blog.csdn.net/danchu/article/details/68961461](http://blog.csdn.net/danchu/article/details/68961461 "http://blog.csdn.net/danchu/article/details/68961461")









