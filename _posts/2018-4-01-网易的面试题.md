---
layout: post
title:  "网易2019的笔试真题"
date:  2018-4-1 10:57:43
categories: algorithm
tags: 算法

---
* content
{:toc}






## 1、牛牛的闹钟

### 题目:

牛牛总是睡过头，所以他定了很多闹钟，只有在闹钟响的时候他才会醒过来并且决定起不起床。从他起床算起他需要X分钟到达教室，上课时间为当天的A时B分，请问他最晚可以什么时间起床 

### 输入描述:
1、每个输入包含一个测试用例。

2、每个测试用例的第一行包含一个正整数，表示闹钟的数量N(N<=100)。

3、接下来的N行每行包含两个整数，表示这个闹钟响起的时间为Hi(0<=A<24)时Mi(0<=B<60)分。

4、接下来的一行包含一个整数，表示从起床算起他需要X(0<=X<=100)分钟到达教室。

5、接下来的一行包含两个整数，表示上课时间为A(0<=A<24)时B(0<=B<60)分。

6、数据保证至少有一个闹钟可以让牛牛及时到达教室。

### 输出描述:

> 输出两个整数表示牛牛最晚起床时间。

### 输入例子1:

> 3 
>
> 5 0 
> 
> 6 0 
> 
> 7 0 
> 
> 59 
> 
> 6 59

### 输出例子1:

> 6 0


### 答案:
```java
import java.util.Arrays;
import java.util.Scanner;

public class Shangke {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);
		// N组数据元素
		int N = sc.nextInt();
		int nums[] = new int[N];
		int Hi, Mi;

		// 起床时间
		for (int i = 0; i < nums.length; i++) {
			Hi = sc.nextInt();
			Mi = sc.nextInt();
			nums[i] = (Hi * 60) + Mi;
		}
		// 排序时间
		Arrays.sort(nums);
		// 路程时间
		int X = sc.nextInt();
		// 上課的時間
		int A = sc.nextInt();
		int B = sc.nextInt();
		int SchoolTime = (A * 60) + B;

		int min = 0;
		for (int i = 1; i < nums.length; i++) {
			if (SchoolTime - X - nums[i] < 0) {
				continue;// 结束本次循环
			} else {
				// 比较最佳闹钟时间
				if (SchoolTime - X - nums[i] < SchoolTime - X - nums[min]) {
					min = i;
				}
			}
		}
		//分钟/60所得的就是小时  分钟%60所得的就是剩下的分钟
		System.out.println(nums[min] / 60 + " " + nums[min] % 60);
	}
}

```



## 2、牛牛找工作

### 题目

为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。 

### 输入描述

1、每个输入包含一个测试用例。

2、每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N<=100000)和小伙伴的数量M(M<=100000)。

3、接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di<=1000000000)和报酬Pi(Pi<=1000000000)。

4、接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai<=1000000000)。

5、保证不存在两项工作的报酬相同。

### 输出描述

对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。

### 输入例子

> 3 3 
> 
> 1 100 
> 
> 10 1000 
> 
> 1000000000 1001 
> 
> 9 10 1000000000

### 输出例子

> 100 
> 
> 1000 
> 
> 1001

### 答案






##  3、被3整除

### 题目

小Q得到一个神奇的数列: 1, 12, 123,...12345678910,1234567891011...。

并且小Q对于能否被3整除这个性质很感兴趣。

小Q现在希望你能帮他计算一下从数列的第l个到第r个(包含端点)有多少个数可以被3整除。


### 输入描述

输入包括两个整数l和r(1 <= l <= r <= 1e9), 表示要求解的区间两端。

### 输出描述

> 输出一个整数, 表示区间内能被3整除的数字个数。

### 输入例子
> 2 5

### 输出例子

> 3
### 例子说明

> 12, 123, 1234, 12345...
> 
> 其中12, 123, 12345能被3整除。

### 答案

```java
import java.util.Arrays;
import java.util.Scanner;

public class Sanzhengchu1 {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		int l = sc.nextInt();
		int r = sc.nextInt();

		// val为具体的值， k为数组索引,count为能整除3的次数
		int val = 0, k = 0, count = 0;

		int nums[] = new int[r - l + 1];

		// 循环生产数字，并放入数组中
		for (int i = l; i <= r; i++) {
			// 当传入2进来的时候，val就等于0+1+2=3
			// 当传入3进来的时候，val就等于0+1+2+3=6
			// 当传入4进来的时候，val就等于0+1+2+3+4=10
			// 当传入5进来的时候，val就等于0+1+2+3+4+5=15
			for (int j = 0; j <= i; j++) {
				val += j;
			}
			// 将3,6,10,15放入数组中
			nums[k] = val;
			// 数组索引下移一位
			k++;
			// clear一下val的值
			val = 0;
		}

		// 为什么要这样写呢，因为我大哥说
		// “如果一个数%3等于0的话，那么这个数的每一个组成数字的和,也是3的倍数”
		// 这句话反过来就是：
		// “如果每一组成数字之和能整除3(或者3的倍数)，那么这个数也是能被3整除”
		// 2-5之间 12,123,1234,12345的和是3,6,10,15。所以结果应该返回3

		for (int i = 0; i < nums.length; i++) {
			if (nums[i] % 3 == 0) {
				count++;
			}
		}
		System.out.println(count);
	}
}

```





## 4、 安置路灯

### 题目

小Q正在给一条长度为n的道路设计路灯安置方案。

为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用'.'表示, 不需要照亮的障碍物格子用'X'表示。

小Q现在要在道路上设置一些路灯, 对于安置在pos位置的路灯, 这盏路灯可以照亮pos - 1, pos, pos + 1这三个位置。

小Q希望能安置尽量少的路灯照亮所有'.'区域, 希望你能帮他计算一下最少需要多少盏路灯。


### 输入描述

1. 输入的第一行包含一个正整数t(1 <= t <= 1000), 表示测试用例数
1. 接下来每两行一个测试数据, 第一行一个正整数n(1 <= n <= 1000),表示道路的长度。
1. 第二行一个字符串s表示道路的构造,只包含'.'和'X'。

### 输出描述
> 对于每个测试用例, 输出一个正整数表示最少需要多少盏路灯。

### 输入例子

> 2
> 3
> .X.
> 11
> ...XX....XX


### 输出例子

> 1
> 3


### 答案
```java
import java.util.Scanner;

public class Ludeng {

	public static void main(String[] args) {

		Scanner scanner = new Scanner(System.in);
		while (scanner.hasNext()) {
			int n = scanner.nextInt();
			while (n-- > 0) {
				int len = scanner.nextInt();
				String line = scanner.next();//用next
				int count = 0;
				for (int i = 0; i < len; i++) {
					if (line.charAt(i) == 'X') {
						continue;
					}
					count++;
					i += 2;
				}
				System.out.println(count);
			}
		}
	}
}
```


## 5、 迷路的牛牛
### 题目

牛牛去犇犇老师家补课，出门的时候面向北方，但是现在他迷路了。虽然他手里有一张地图，但是他需要知道自己面向哪个方向，请你帮帮他。 

### 输入描述

1. 每个输入包含一个测试用例。
1. 每个测试用例的第一行包含一个正整数，表示转方向的次数N(N<=1000)。
1. 接下来的一行包含一个长度为N的字符串，由L和R组成，L表示向左转，R表示向右转。
### 输出描述

> 输出牛牛最后面向的方向，N表示北，S表示南，E表示东，W表示西。

### 输入例子

> 3
> LRR

### 输出例子

> E

### 答案
```java
import java.util.Scanner;

public class Fangxiang {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		String s = sc.next();
		// 分别代表 0 1 2 3
		char[] F = { 'N', 'E', 'S', 'W' };
		int index = 0;

		for (int i = 0; i < n; i++) {
			
			if (s.charAt(i) == 'R') {
				//如果index加到了3，边界值重置
				if (index == F.length - 1) {
					index = 0;
				} else {
					index++;
				}
			} else {
				//如果index减到0，边界值重置
				if (index == 0) {
					index = F.length - 1;
				} else
					index--;
			}
		}
		System.out.println(F[index]);
	}
}

```








##   6、数对
### 题目

牛牛以前在老师那里得到了一个正整数数对(x, y), 牛牛忘记他们具体是多少了。

但是牛牛记得老师告诉过他x和y均不大于n, 并且x除以y的余数大于等于k。
牛牛希望你能帮他计算一共有多少个可能的数对。

### 输入描述

输入包括两个正整数n,k(1 <= n <= 10^5, 0 <= k <= n - 1)。

### 输出描述

对于每个测试用例, 输出一个正整数表示可能的数对数量。

### 输入例子

> 5 2

### 输出例子
> 7
### 例子说明1:

> 满足条件的数对有(2,3),(2,4),(2,5),(3,4),(3,5),(4,5),(5,3)

### 答案








##  7、矩形重叠
### 题目
平面内有n个矩形, 第i个矩形的左下角坐标为(x1[i], y1[i]), 右上角坐标为(x2[i], y2[i])。

如果两个或者多个矩形有公共区域则认为它们是相互重叠的(不考虑边界和角落)。

请你计算出平面内重叠矩形数量最多的地方,有多少个矩形相互重叠。

### 输入描述

1. 输入包括五行。
1. 第一行包括一个整数n(2 <= n <= 50), 表示矩形的个数。
1. 第二行包括n个整数x1[i](-10^9 <= x1[i] <= 10^9),表示左下角的横坐标。
1. 第三行包括n个整数y1[i](-10^9 <= y1[i] <= 10^9),表示左下角的纵坐标。
1. 第四行包括n个整数x2[i](-10^9 <= x2[i] <= 10^9),表示右上角的横坐标。
1. 第五行包括n个整数y2[i](-10^9 <= y2[i] <= 10^9),表示右上角的纵坐标。

### 输出描述

> 输出一个正整数, 表示最多的地方有多少个矩形相互重叠,如果矩形都不互相重叠,输出1。

### 输入例子
> 2
> 0 90
> 0 90
> 100 200
> 100 200

### 输出例子
> 2

### 答案



##  8、牛牛的背包问题
### 题目
牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为w。
牛牛家里一共有n袋零食, 第i袋零食体积为v[i]。
牛牛想知道在总体积不超过背包容量的情况下,他一共有多少种零食放法(总体积为0也算一种放法)。

### 输入描述

1. 输入包括两行
1. 第一行为两个正整数n和w(1 <= n <= 30, 1 <= w <= 2 * 10^9),表示零食的数量和背包的容量。
1. 第二行n个正整数v[i](0 <= v[i] <= 10^9),表示每袋零食的体积。

### 输出描述
> 输出一个正整数, 表示牛牛一共有多少种零食放法。

### 输入例子
> 3 10
> 1 2 4

### 输出例子
> 8
### 例子说明1:
> 三种零食总体积小于10,于是每种零食有放入和不放入两种情况，一共有2*2*2 = 8种情况。
### 答案


