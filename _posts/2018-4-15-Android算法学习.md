---
layout: post
title:  "Android算法学习"
date:  2018-4-15 23:01:12
categories: algorithm
tags: 算法

---
* content
{:toc}






## 冒泡排序

**基本思想**：

一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序为止。

**代码**

```java
public static void main(String[] args) {
    int[] nums = {3, 1, 7, 5, 8, 9, 23, 45};
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < nums.length - 1 - i; j++) {
            if (nums[j] > nums[j + 1]) {// 如果前面大于后面，则互换
                int temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
    for (int j = 0; j < nums.length; j++) {
        System.out.print(nums[j] + " ");
    }
}
```

## 简单选择排序

**基本思想**：

- 首先找出数组中最小的那个元素，将它和数组的第一个元素交换位置。
- 在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。
- 如此往复，直到将整个数组排序。

**总结**：

- 运行时间和输入无关。
- 数据移动是最少的。

通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交互。

**过程**：

> **6** 3 5 7 **0** 4 1 2      找到最小值 0 与 当前 i = 0 相交互。N=0
> 
> **0** 3 5 7 **6** 4 1 2  
> 
> 0 **3** 5 7 6 4 **1** 2       找到最小值 1 与 当前 i = 1 相交互。N=1
> 
> 0 **1** 5 7 6 4 **3** 2 
> 
> 0 1 **5** 7 6 4 3 **2**        找到最小值 1 与 当前 i = 1 相交互。N=2
> 
> 0 1 **2** 7 6 4 3 **5**
> . . .

**代码**：

```java
public static void main(String[] args) {
    int[] num = {99, 57, 2, 45, 65, 33, 12};
    int min;
    for (int i = 0; i < num.length; i++) {
        min = i;// 将当前下标定义为最小值下标
        for (int j = i + 1; j < num.length; j++) { // 循环比较
            if (num[min] > num[j]) {               // 相邻的两个数字,找到最小的
                min = j;                           // 将此关键字的下标赋值给min
            }
        }
        if (i != min) {                // 若min不等于i，说明找到最小值，进行交换
            int temp = num[i];
            num[i] = num[min];
            num[min] = temp;
        }
    }
    for (int i : num) {
        System.out.print(i + " ");
    }
}
```

## 插入排序

**基本思想**：

Straight Insertion Sort 是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。

1、先把当前 nums[i] 的值传给第三方空间 insertNote。

2、判断 insertNote 是否 小于 nums[j]， nums[j] 是 nums[i] 前一个数，j=i-1。

3、是小于，将 j 的值放到 j+1 值里面去，也就是当前 i 的位置。同时 j - -，再往前找。

4、如果 insertNote 仍然小于上上家 j-2， 将 j 的值放到之前 j 值里面去，也就是当前 j-1 的位置，j - -。

**过程**：

> 6 5 3 1 8 7 2 4 
> 
> [6] 5 3 1 8 7 2 4 
> 
> [5 6] 3 1 8 7 2 4 
> 
> [3 5 6] 1 8 7 2 4
>  
> [1 3 5 6] 8 7 2 4 
> 
> [1 3 5 6 8] 7 2 4 
> 
> [1 3 5 6  7 8] 2 4
>  
> [1 2 3 5 6  7 8] 4 
> 
>  [1 2 3 4 5 6  7 8]  


**代码**：

```java
public static void main(String[] args) {
    int num[] = {6, 5, 3, 1, 8, 7, 2, 4};
    int i, j, insertNote;// 要插入的数据
    for (i = 1; i < num.length; i++) {// 从数组的第二个元素开始循环将数组中的元素插入
        insertNote = num[i];// 设置数组中的第2个元素为第一次循环要插入的数据
        j = i - 1;// 前一个元素
        while (j >= 0 && insertNote < num[j]) {
            num[j + 1] = num[j];// 如果要插入的元素小于第j个元素,就将第j个元素向后移动
            j--;
        }
        num[j + 1] = insertNote;// 直到要插入的元素不小于第j个元素,将insertNote插入到数组中
    }
    for (int k : num) {
        System.out.print(k + " ");
    }
}
```

## 三种简单排序之间的比较：

1. 时间复杂度为O(n^2)
2. **冒泡排序**：除非手边没有算法书可参照，一般情况很少用冒泡排序算法；当数据量很小的时候它会有价值外，其余都不建议使用。
3. **选择排序**：虽然把交换次数降到了最低，但比较的次数仍比较大。当数据量很小，并且交换数据相对比较数据更加耗时的情况下，可以使用选择排序。
4. **插入排序**：当数据量比较小或基本有序时，插入排序算法是三种排序中最好的选择。


## 归并排序



**缺点**：

归并排序需要在存储器重有另一个大小等于被排序的数据项数目的数组，如果初始数组几乎沾满整个存储器，那么归并排序将不能工作。但是有足够空间，归并排序会是一个很好的选择。


**归并两个有序的数组：腾讯面试例子**：

> 设数组 A 有 4 个数据项，数组 B 有 6 个数据项。它们要被归并到数组 C 中，在开始时数组 C 有 10 个空的存储空间。
> 
> 数组 A：23，47，81 ，95
> 
> 数组 B：7，14 ，39 ，55 ，62 ，74
> 
> 数组 C：7 14 23 39 47 55 62 74 81 95

**代码**：

```java
public static void main(String[] args) {
    int[] a = {23, 47, 81, 95};
    int[] b = {7, 14, 39, 55, 62, 74};
    int[] c = new int[a.length + b.length];
    // 归并排序
    merge(a, 4, b, 6, c);
    // 输出
    for (int k = 0; k < c.length; k++) {
        System.out.print(c[k] + " ");
    }
}
private static void merge(int[] a, int i, int[] b, int j, int[] c) {
    int adex = 0, bdex = 0, cdex = 0;// 索引
    // 循环将小的放进数组
    while (adex < i && bdex < j)
        if (a[adex] < b[bdex])
            c[cdex++] = a[adex++];
        else
            c[cdex++] = b[bdex++];
    // 当B数组的数据项已经全部移出了
    while (adex < i)
        c[cdex++] = a[adex++];
    // 当A数组的数据项已经全部移出了
    while (bdex < j)
        c[cdex++] = b[bdex++];
    }
```

**基本思想**：

把一个数组分成两半，排序每一半，然后用merge()方法把数组的两半并成一个有序的数组。

**具体过程**：

- 1、通过不断的递归 mergeSort() 方法，在 mergeSort() 方法中，每一次这个方法调用自身的时候，排列都会被分成两半。把每个一半都分成两个四分之一，再分成两个一半八分之一、十六分之一以此类推反复分割数组。

- 2、当 mergeSort() 方法发现两个只有 1 个数据项的数组时，它就返回，把 2 个数据项归并到一个只有 2 个数据项的有序数组中。每生成一对 2 个数据项的数组又被合并成一个有 4 个数据项的有序数组。这个过程一直持续下去，数组越来越大直到数组有序。

- 总之，先拆后拼。

**代码**：

```java
    public static void main(String[] args) {

        int nums[] = {51, 30, 90, 10, 70, 40, 80, 60, 20};
        MergeSort(nums, 0, nums.length - 1);
        System.out.println("排序结果：" + Arrays.toString(nums));
    }

    private static void MergeSort(int[] nums, int start, int end) {

        int middle = (start + end) / 2;  //计算中间位置
        if (start < end) {
            MergeSort(nums, start, middle);  // min-mid 对左边数据集在拆分，递归自己
            MergeSort(nums, middle + 1, end);  // mid-max 对右边数据集在拆分，递归自己
            merge(nums, start, middle, end);   // 归并两个有序的部分
        }
    }

    public static void merge(int[] a, int start, int mid, int end) {
        int[] temp = new int[end - start + 1];
        int i = start;// 左指针
        int j = mid + 1;// 右指针
        int k = 0;
        // 把较小的数先移到新数组中，i--->mid，j--->max
        while (i <= mid && j <= end) {
            if (a[i] < a[j]) {
                temp[k++] = a[i++];
            } else {
                temp[k++] = a[j++];
            }
        }
        // 把左边剩余的数移入数组
        while (i <= mid) {
            temp[k++] = a[i++];
        }
        // 把右边边剩余的数移入数组
        while (j <= end) {
            temp[k++] = a[j++];
        }
        // 把新数组中的数覆盖nums数组
        for (int k2 = 0; k2 < temp.length; k2++) {
            a[k2 + start] = temp[k2];
        }
    }
```

## 快速排序

**基本思想**：

- 1、快速排序采用了分治策略，就是在一个数组中取一个基准数字，把小的数放基准的左边，大的数放基准的右边。

- 2、基准左边和右边分别是新的序列，在新的序列中再取一个基准数字，小的放左边，大的放右边。

- 3、这个里面用到的递归，我们需要三个参数，一个是数组，另外两个是序列的边界。


```java

    public static void main(String[] args) {

        int[] nums = {50, 10, 90, 30, 70, 60, 80, 40, 20};
        QSort(nums, 0, nums.length - 1);
        System.out.print(Arrays.toString(nums));

    }

    private static void QSort(int[] nums, int left, int right) {
        int pivot;
        if (left < right) {
            pivot = Partition(nums, left, right); // 算出枢轴值
            QSort(nums, left, pivot - 1); // 对低子表递归排序
            QSort(nums, pivot + 1, right); // 对高子表递归排序
        }
    }

    // 调用partition(num,left,right)时，对num[]做划分， 并返回基准记录的位置
    private static int Partition(int[] nums, int left, int right) {

        if (nums == null || nums.length <= 0 || left < 0
                || right >= nums.length) {
            return 0;
        }

        int prio = nums[(right + left) / 2]; // 获取数组中间元素的下标

        while (left <= right) { // 从两端交替向中间扫描
            while (nums[left] < prio)
                left++;
            while (nums[right] > prio)
                right--;
            if (left <= right) {
                swap(nums, left, right); // 最终将基准数归位
                left++;
                right--;
            }
        }
        return left;
    }

    public static void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
```














