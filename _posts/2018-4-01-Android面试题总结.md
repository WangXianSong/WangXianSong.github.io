---
layout: post
title:  "Android面试题笔记"
date:  2018-4-1 19:58:15
categories: 面试
tags: 面试

---
* content
{:toc}





## 前言：面试前的准备：

### 面试过程中的要求：

- 1.礼貌：态度谦虚
- 2.听懂问题直接回答

### 面试技巧

- 1.根据简历来面试、根据项目需求来面试、根据牛人来面试。
- 2.遇到难题时，可以向面试官提出，“我没有听清楚，刚出可能外面有些噪音，你能不能重复一下问题”，来为自己争取时间。实在回答不出，也不能说不知道，可以将题目拆分来成123小点来逐一回答。可以离题、可以扯别的问题。
- 3.实在不会就可以说下想法就好，绝对不可以说不知道。

### 面试建议：

- 1.选一个自己相对比较擅长的领域。（源码深入）
- 2.基础要背（灵活背）
- 3.试着去了解这个领域市面上的技术。
- 4.如果有时间 研究其中一个众所周知的库的源码。




## 一、基本概念

### Android 四大组件是什么

- **Activity 活动 :**

Activity用于显示界面，它上面可以显示控件、监听控件并处理用户的事件做出响应。

- **Service 服务：**

是Android 中实现程序后台运行的解决方案，适合不需要和用户交互而且还要求长期运行的任务。依赖于创建服务的程序，程序被杀掉，服务也停止运行。服务不会自动开启线程，需要服务内部创建子线程。

- **Broadcast Receiver 广播接收器:**

应用程序可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个 Activity 或 Serice 来响应它们收到的信息，或者用NotificationManager 来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等。

- **Content Provider内容提供者 :**

内容提供器主要用于在不同的应用程序之间实现数据共享的功能，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据的安全性。

### Android平台的framework的层次结构？

- Linux Kernel(**Linux内核**)
- Hardware Abstraction Layer(**硬件抽象层**)
- Libraies(**系统运行库**或者是c/c++**核心库**)
- Application Framework(**开发框架包** )
- Applications(**核心应用程序**)

### 请介绍下Android中常用的布局。

答：常用四种布局方式，分别是：FrameLayout（帧布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局）。

（1）**FrameLayout**：所有东西依次都放在左上角，会重叠，这个布局比较简单，也只能放一点比较简单的东西。

（2）**LinearLayout**：线性布局，每一个LinearLayout里面又可分为垂直布局（android:orientation="vertical"）和水平布局（android:orientation="horizontal" ）。当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。

（3）**AbsoluteLayout**：绝对布局用X,Y坐标来指定元素的位置，这种布局方式也比较简单，但是在屏幕旋转时，往往会出问题，而且多个元素的时候，计算比较麻烦。

（4）**RelativeLayout**：相对布局可以理解为某一个元素为参照物，来定位的布局方式。主要属性有：相对于某一个元素android:layout_below、 android:layout_toLeftOf相对于父元素的地方android:layout_alignParentLeft、android:layout_alignParentRigh；

### 动画有哪几类，它们的特点和区别是什么

**(1) 视图动画**：定义了透明度、平移、缩放、旋转动画。实现原理：是每次绘画视图时，View 所在的 ViewGroup 中的 drawChild 函数获取该 View 的 Animation 的 Transformation 值，然后调用 canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧。缺点：是不具备交互性，当某个元素发生 View 动画后，其响应事件的位置仍然在动画前的地方。

**(2) 属性动画**：在一定时间间隔内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果，响应点击事件的有效区域也会发生改变。比较常用的几个动画类是：**ValueAnimator**(注重过程)、**ObjectAnimator**(具体操作) 和 **AnimatorSet**(组合)，其中 ObjectAnimator 继承自 ValueAnimator，AnimatorSet 是动画集合。

### Drawable

### android 中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别。

Android 提供了三种解析XML的方式：**SAX(Simple API XML)** , **DOM(Document Object Model)**, **Pull** 

**SAX解析方式**：(Simple API for XML)解析器是一种基于事件的解析器，事件驱动的流式解析方式是，从文件的开始顺序解析到文档的结束，不可暂停或倒退。 


## 二、Activity 面试详解

### 1、Activity的四种状态：

- **running**：处于活动状态，用户可以点击屏幕，屏幕会做出响应，处于Activity 的栈顶。
- **paused**：处于失去焦点状态或者被一个非全屏的Activity占据，又或者被一个透明的Activity放置栈顶。Activity只是失去和用户的交互能力，处于内存紧张状态。
- **stopped**：被另外的 Activity 全屏覆盖，不再是可见的，
- **killed**：Activity 已经被系统回收掉了。

### 2、Activity 在各种情况下的生命周期：

- **Activity启动** ：onCreate()初始化 -> onstart()可见了 -> onResume()可交互了
- **锁屏或Home键或新覆盖**： onPause() -> onStop()有可能被杀掉
- **解锁或回到前台**：onRestart()重新启动 -> onStart() -> onResume() 
- **退出 或Back键** ：onPause() -> onStop() -> onDestroy()回收，资源释放。
- **弹出对话框**：不会执行任何生命周期(注：对话框如果是Activity(Theme为Dialog)，还是会执行生命周期的)
- **从A跳转到B**：当B的主题为透明时，A只会执行onPause（A-onPause->B-(onCreate->onStart->onResume)）
- **从A跳转到B**：A-onPause->B-(onCreate->onStart->onResume)-A-onStop  (注意是B执行onResume后，A才执行onStop，所以尽量不要在onPause中做耗时操作)
- **从B返回到A**：B-onPause->A-(onRestart->onStart->onResume)-B-(onStop->onDestroy)

### 3、Activity之间的通信方式

- 1)在Intent跳转时携带数据 
- 2)借助类的静态变量
- 3)借助全局变量/Application
- 4)借助外部存储来实现通讯
  - 借助SharedPreference 
  - 使用Android数据库SQLite 
  - 赤裸裸的使用File 
- 5)借助Service

### 4、Activity上有 Dialog 的时候按Home键时的生命周期

**生命周期是**：onCreate() -> onStart() -> onResume -> 启动Dialog-> home键 -> onPause() -> onStop() 

 其实就是一个很正常的 Activity 生命周期，并没有什么特别的地方，但是注意 onPause 方法和 onStop 方法是在我点击 Home 键之后才有的，这就说明对话框的出现并没有使 Activity 进入后台。而是点击Home键才使Activity进入后台工作。AlertDialog对话框实际上是Activity的一个组件。

### 5、横竖屏切换的时候，Activity 各种情况下的生命周期

1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。

2、设置Activity的android:configChanges="orientation"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次。

3、设置 Activity的android:configChanges="orientation | keyboardHidden" 时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged 方法。

### 6、Activity与Fragment之间生命周期比较

- Activity——onCreate->onStart->onResume->onPause->onStop->onDestroy
- Fragment——onAttach->onCreate->onCreateView->onActivityCreated->onStart->onResume ->onPause->onStop->onDestroyView->  onDestroy->onDetach


### 7、Activity 进程优先级

**前台**：处于与用户交互的 Activity，或者在前台绑定的 Service。
**可见**：处于前台，但用户又不能点击的情况下。
**服务**：在后台开启 Service服务。
**后台**：用户按了Home键回到了桌面，根据内存情况作出相应的回收。
**空**：优先级最低，处于缓存的目的而保留，系统随时杀掉。

### 8、Activity 启动模式

- **standard**：标准模式，这也是系统的默认模式。每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在；

- **singleTop**：栈顶复用模式。(1) 如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的**onNewIntent**方法会被回调。(2) 需要注意的是，这个Activity的onCreate、onStart不会被系统调用，因为它并没有发生改变。(3) 如果新的Activity的实例已经存在但不是位于栈顶，那么新的Activity仍然会重新创建；

- **singleTask**：栈内复用模式。这是一种单实例模式，在这种情况下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewIntent；

- **singleInstance**：单实例模式，这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中。

### 9、scheme 跳转协议

是一种页面跳转协议，是一种非常好的实现机制，通过定义自己的scheme协议，可以非常方便跳转app的各个页面；通过scheme 协议，服务器可以定制化告诉App跳转哪个页面，可以通过通知栏消息定制化跳转页面，可以通过H5页面跳转页面。
- 1.服务端下发url，客户端根据url跳转到相应的页面。
- 2.H5跳转到App相应的Activity。
- 3.App根据url跳转到另一个App指定页面。

### 10、Activity状态保存于恢复

在《第一行代码》的 63 页中有详细介绍：
Activity中提供了一个onSaveInstanceState()回调方法，只要在代码中将临时数据保存在Bundle类型中，在Activity的onCreate方法中去获取数据即可。


### 11、简述横竖屏切换时Activity的生命周期；如何将横竖屏切换对应的影响降至最低？

### 快速退出所有Activity(关闭多个Activity)？

只需要用一个专门的收集类对所有的活动进行管理就可以了，在《第一行代码》的72页中有详细介绍：

新建ActivityCollector类作为活动管理器。









## 三、Fragment面试详解

碎片是一种可以嵌入在Activity当中的UI片段，它能让程序更加合理和充分地利用在大屏幕的空间，因而在平板上应用非常广泛，是Android自3.0版本开始引入的。

### Fragment 为什么被称为 第五大组件

(1) 首先在使用频率上，Fragment是不属于四大组件的范畴，他有自己的生命周期。
(2) 同时它可以灵活动态加载到 Activity 当中去。
(3 )而且 Fragment 并不像 Activity 那样独立的，虽然有自己的生命周期，但需要依附Activity。

### Fragment 加载到Activity的两种方式

- **静态加载**：作为XML标签添加到 Activity 的布局文件当中。(过程省略...)
- **动态加载**：动态在 Activity 中添加 Fragment 。 (常用)

```java
//前提1：先创建 Fragment1.java，并继承 Fragment，在onCreatview中初始化fragment的XML布局文件
//前提2：在Fragment1的XML布局文件中准备好容器R.id.lin_id

//步骤1：添加FragmentTransaction的实例
FragmentManager fragmentManager = getFragmentManager();
FragmentTransaction transaction = fragmentManager.beginTransaction();
//步骤2:用add()加Fragment对象fragment1，并绑定到其XML页面里的容器内
Fragment1 fragment1 = new Fragment1();
transaction.add(R.id.lin_id, fragment1, "fragment1");
//步骤3：调用commit方法使得FragmentTransaction实例的改变生效
transaction.commit();
```

### FragmentPagerAdapter 与 FragmentStatePagerAdaper 区别：

**FragmentPagerAdapter** ：FragmentPagerAdapter 在切换 ViewPager 的时候，只是把 Fragment的UI 与 Activity的UI 脱离开来，并不回收内存。所以它适用页面**减少**的情况。(在其源码 DestroyItem 方法中的最后一行，mCurTransaction.**detach** 可知)

**FragmentStatePagerAdaper** ：由于 FragmentStatePagerAdaper 在每次切换 ViewPager 的时候，它是回收内存的。又因为在页面较多的情况下会更耗内存，所以它适合页面**较多**的情况。(在源码 DestroyItem 方法中的最后一行，mCurTransaction.**remove** 可知 )

### Fragment 的生命周期

**onAttach**:表示在 Fragment 与 Activity 关联之后所回调的。

**onCreate**:表示初次创建 Fragment 的时候调用。(仅用来创建，但为完成)

**onCreateView**:系统在 Fragment 的首次**绘制**用户界面的时候调用。

**onViewCreated**:表示 Fragment 的UI界面已经绘制好了，可以初始化里面的控件资源。

*Activity - onCreate*:初始化Activity 的布局和数据之类。

**onActivityCreated**:在 Activity - onCreate()调用完成后才可以被调用，表示Activity被渲染绘制成功以后的调用方法。

*Activity - onStart*:表明 Activity 可见了。

**onStart**:表明 Fragment 也可见了。

*Activity - onResume*:表示 Activity 可以和用户交互了。

**onResume**:表示 Fragment 也可以和用户交互了。

  ↑  (到此为止已经完成了 Fragment 从启动到展现的操作。)

  ↓ (回退Fragment)

**onPause**: Fragment 无法和用户交互。

*Activity - onPause*:整个Activity 也无法和用户交互。

**onStop**:做一些相应的保存与释放。

*Activity - onStop*:做一些相应的保存与释放。

**onDestroyView**:对应创建的onCreateView，表示 Fragment 即将结束，然后会被保存。

**onDestroy**:表示 Fragment 不再被使用。

**onDetach**: Fragment 的最后一个方法，Fragment不再被使用。

*Activity - onDetach*:整个Activity被回收了。

简单的Fragment流程图—— onAttach->onCreate -> onCreateView -> onActivityCreated -> onStart -> onResume  ->创建成功-> onPause->onStop->onDestroyView -> onDestroy->onDetach

### Fragment 之间的通信  (课后复习)

- 在 Fragment 中调用 Activity 中的 **getActivity** 方法；
- 在 Activity(实现) 中调用 Fragment(创建接口) 中的方法 **接口回调；**
- 在 Fragment 中调用 Fragment 中的 **findFragmentById** 方法；

### Fragment 的 replace、add、remove 方法

- **replace** 是 FragmentManager 的方法，是将 Activity 最上层的 Fragment **替换**掉。
- **add** 将 Fragment 的实例添加到 Activity 的**最上层**；
- **remove** 将 Fragment 的实例从 Activity 的队列中**删除**；

### Fragment 管理器 FragmentManager
### fragment各种情况下的生命周期
### Fragment状态保存 startActivityForResult 是哪个类的方法，在什么情况下使用？

### 如何实现Fragment的滑动？
ViewPager + Fragment
### fragment之间传递数据的方式？

### Fragment 特点

- Fragment 可以作为 Activity 界面的一部分组成出现；
- 可以在一个 Activity 中同时出现多个 Fragment，并且一个 Fragment 也可以在多个 Activity 中使用；
- 在 Activity 运行过程中，可以添加、移除或者替换 Fragment；
- Fragment 可以响应自己的输入事件，并且有自己的生命周期，它们的生命周期会受宿主 Activity 的生命周期影响。
- Fragment 可以轻松得创建动态灵活的 UI 设计，可以适应于不同的屏幕尺寸。从手机到平板电脑。
- Fragment 解决 Activity 间的切换不流畅，轻量切换。
- Fragment 替代 TabActivity 做导航，性能更好。
- Fragment 做局部内容更新更方便，原来为了达到这一点要把多个布局放到一个 activity 里面，现在可以用多 Fragment 来代替，只有在需要的时候才加载 Fragment，提高性能。

### Fragment嵌套多个Fragment会出现bug吗？

参考：http://blog.csdn.net/megatronkings/article/details/51417510

### 怎么理解Activity和Fragment的关系？

- Fragment 拥有和 Activity 一致的生命周期，它和 Activity 一样被定义为 Controller 层的类。有过中大型项目开发经验的开发者，应该都会遇到过 Activity 过于臃肿的情况，而 Fragment 的出现就是为了缓解这一状况，可以说 它将屏幕分解为多个「Fragment（碎片）」（这句话很重要），但它又不同于 View，它干的实质上就是 Activity 的事情，负责控制 View 以及它们之间的逻辑。
- 将屏幕碎片化为多个 Fragment 后，其实 Activity 只需要花精力去管理当前屏幕内应该显示哪些 Fragments，以及应该对它们进行如何布局就行了。这是一种组件化的思维，用 Fragment 去组合了一系列有关联的 UI 组件，并管理它们之间的逻辑，而 Activity 负责在不同屏幕下（例如横竖屏）布局不同的 Fragments 组合。
- 这种碎片不单单能管理可视的 Views，它也能执行不可视的 Tasks，它提供了 retainInstance 属性，能够在 Activity 因为屏幕状态发生改变（例如切换横竖屏时）而销毁重建时，依然保留实例。这示意着我们能在 RetainedFragment 里面执行一些在屏幕状态发生改变时不被中断的操作。例如使用 RetainedFragment 来缓存在线音乐文件，它在横竖屏切换时依然维持下载进度，并通过一个 DialogFragment 来展示进度。


## 三、Service面试详解
### Service 是什么？

Service 是一种可以在后台执行长时间运行操作而没有用户界面的应用组件。(Service 不能做耗时操作)

### Service 和 BroadcastReceiver 共同点

都是运行在主线程当中，都不能做长时间的耗时操作。

### Service 和 Thread 的区别
- 定义: 

Thread 是程序执行的最小单元，它是分配CPU的最小单位。可以执行异步操作，是相对**独立**的。
Service 是Android的一种特殊机制，Service是运行在主线程当中的，是**依托于**所在的主线程。是由系统进程托管，也是一种轻量级IPC通信方式(Activity 和 Service 绑定，然后数据通信，并处于不同进程。 )

- 关系:

Service 和 Thread 之间并没有什么关联，Service 翻译成中文是服务，同时服务可以理解为后台。Thread 是开启子线程执行耗时操作，而 Service 是在主线程中执行，但总被认为可以在后台处理耗时任务，容易混淆了两者之间的概念。

- 实际开发中:

在Android系统当中，线程一般指的是工作线程，主线程主要负责UI绘制，而Service 就是运行在主线程当中的。

- 应用场景

当需要耗时的操作，比如网络请求，图片加载等等都应该使用工作线程。
当需要在后台播放音乐、开启定位、数据统计等等应该使用Service。

- 区分

1.不要把后台和子线程联系在一起；
2.服务和后台是不同的概念；
3.Android的后台是指它的运行不依赖与UI线程，即使程序被销毁了、程序被关闭了，服务进程仍然在后台进行计算、统计等等。
4.如果在 Service 执行耗时，也需要创建子线程，然后去做耗时逻辑。
5.Service是为了弥补 Activity 被销毁之后，无法获取之前所创建的子线程实例，并对后台进行控制的情况而产生的。

### 开启 Service 的两种方式以及区别

- **StartService**

1.定义一个类继承 Service
2.在Manifest.xml文件中配置该 Service
3.使用Context的startService(Intent)方法启动Service
4.不再使用时，调用 stopService(Intent) 方法停止该服务。

onBind
onCreated
onStartCommand：
onDestroy：不再使用服务，资源回收。

- **bindService**:

绑定服务提供了客户端和服务端接口，进行数据的交互(发送请求、获取结果、进程间通信)
1.创建BindService服务端，继承自Service，并在类中创建一个实例IBinder接口实现对象并提供公共方法给客户端调用。
2.从onBind()回调方法返回此Binder实例
3.在客户端中，从onServiceConnected()回调方法接收Binder，并使用提供的方法调用绑定服务。


### Service 的生命周期

**StartService** ：onCreat -> onStartCommand -> running -> stopService/stopSelf -> onDestroy

如果这个服务之前没有创建过，onCreate方法会先于 onStartCommand 方法执行，服务启动后一直保持运行状态，直到 stopService 或 stopSelf() 方法被调用。

**bindService**：onCreat -> onBind ->onUnBind -> onDestroy

如果这个服务之前没有创建过，onCreate方法会先于 onBind 方法执行，服务启动后一直保持运行状态，直到 unBindService 方法被调用。

**StartService+bindService**：同时被调用的情况下，需要同时调用 stopService和unBindService。




### Activity 怎么和 Service 绑定？
### 怎么在Activity 中启动自己对应的Service？
### service 和 activity 怎么进行数据交互？




## 四、Content Provider
### 谈谈你对ContentProvider的理解
### 说说ContentProvider、ContentResolver、ContentObserver 之间的关系


## 五、Broadcast Receiver
### 广播的定义

在Android 中，Broadcast 是一种广泛运用的在应用程序之间传输信息的机制，Android 中我们要发送的广播内容是一个Intent，这个Intent中可以携带我们要传送的数据。

广播实现了不同程序之间的**信息传输与共享**，只要和发送广播的action相同的接收者，都能接收到这个广播。还可以作为**通知**的作用，发送消息给service来更新UI。

类似设计模式中的“观察者模式”，当被观察者数据发生变化的时候，会去相应的通知观察者做相应的数据处理。

### 广播的场景

- 同一个App具有多个进程的不同组件之间的消息通信。
- 不同App之间的组件之间消息通信。

### 广播的种类

- **标准广播 Normal Broadcast **：一种完全异步执行的广播，所有接受者在同一时刻收到这条广播消息。效率高，没有先后顺序，无法截断。
- **有序广播 Ordered Broadcast**：一种同步执行的广播，同一时刻只会有一个广播接收器能够接收到这条广播消息。先后顺序，优先级，可截断。

### 实现广播 receiver

- **静态注册** : 将广播写在 AndroidMainifest.xml 文件当中，特点是:Activity 销毁了或进程被杀死了，仍然能接收广播。**注册完成就一直运行**
- **动态注册** : 在代码中调用 registerReceiver() 注册来进行广播的注册。必须在onDestroy中调用unregisterReceiver()方法，否则会引起内存泄露。**生命周期是跟随Activity的生命周期**

### 广播实现机制

### LocalBroadcastManager详解

### 请描述一下广播Broadcast Receiver的理解
### 广播的分类
### 广播使用的方式和场景
### 在manifest 和代码中如何注册和使用BroadcastReceiver?
### 本地广播和全局广播有什么差别？
### BroadcastReceiver，LocalBroadcastReceiver 区别


## 六、

### AlertDialog，popupWindow，Activity区别
### Application 和 Activity 的 Context 对象的区别
### Android属性动画特性
### 如何导入外部数据库?
### LinearLayout、RelativeLayout、FrameLayout的特性及对比，并介绍使用场景。
### 谈谈对接口与回调的理解
### 回调的原理
### 写一个回调demo
### 介绍下SurfView
### RecycleView的使用
### 序列化的作用，以及Android两种序列化的区别
### 差值器
### 估值器
### Android中数据存储方式







### Handler机制原理

### service生命周期
### 如何理解Activity，View，Window三者之间的关系？
### 运行时权限 p245页
### ART、Dalvik和JVM的关系及区别是什么？

这是道送分题，并不是真的要说出它们的深度区别，但如果你不知道ART是什么，我觉得你不够关注行业发展，靠这个平台吃饭，不关心它，怎么都说不过去。

- ART 就是 Android Runtime ，是安卓4.4之后的系统的新的虚拟机模式，改模式提升了运行效率，启用该模式之后，系统在安装APP的时候，会进行一次预编译，把代码转成机器语言存储在本地，这样运行的时候效率就高了。
- Dalvik 是一种安卓系统在上面运行的虚拟机，因为安卓系统是以Linux 为底层构建的，为了更加高效的适配到各种不同的硬件设备上面，就创建了这个Dalvik 虚拟机，该虚拟机可以将程序的语言由java转成机器语言二进制运行，然而每次开启运用的时候都会执行一次编译，所以效率不是很高，所以我们需要ART，增加效率。
- JVM 是 java虚拟机，是实现java夸平台的主要方式，可以使得java这样的高级语言编译成机器可以识别的机器语言，这样使得java 一次编译，到处运行。


### 3.Binder机制。难，基本个大概的概念也没有多少个人说的全的。
Binder机制 是一种进程间通信机制，提供了远程过程调用功能，就是RPC。他把系统的一系列组件连接在了一起，这些组件分别是上层的 Client 和server,中间层的 Service Manager，该组件 ；底层的 Binder驱动程序，系统的核心组件。开发者只要实现要client和server就可以了。



### ANR完全解析
https://www.jianshu.com/p/124f3b75e164
### Volley
### RxJava
### Retrofit
### okhttp原理
### Java GC原理
### oom
### Android UI适配
### Android内存泄露及管理
### 共享数据的方式
### xml json gson区别
### 设计模式
### MVC MVP
https://juejin.im/entry/56ebb4ad5bbb50004c440972
### handler
https://blog.csdn.net/wzhworld/article/details/78337641
### AsyncTask
### Binder
Binder是Android系统进程间通信（IPC）方式之一。Linux已经拥有的进程间通信IPC手段包括(Internet Process Connection)： 管道（Pipe）、信号（Signal）和跟踪（Trace）、插口（Socket）、报文队列（Message）、共享内存（Share Memory）和信号量（Semaphore）。本文详细介绍Binder作为Android主要IPC方式的优势。
### 垃圾回收
https://blog.csdn.net/wzhworld/article/details/78315589