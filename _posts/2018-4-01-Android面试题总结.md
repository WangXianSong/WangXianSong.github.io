---
layout: post
title:  "Android面试题笔记"
date:  2018-4-1 19:58:15
categories: 面试
tags: 面试

---
* content
{:toc}





## 前言：面试前的准备：

### 面试过程中的要求：

- 1.礼貌：态度谦虚
- 2.听懂问题直接回答

### 面试技巧

- 1.根据简历来面试、根据项目需求来面试、根据牛人来面试。
- 2.遇到难题时，可以向面试官提出，“我没有听清楚，刚出可能外面有些噪音，你能不能重复一下问题”，来为自己争取时间。实在回答不出，也不能说不知道，可以将题目拆分来成123小点来逐一回答。可以离题、可以扯别的问题。
- 3.实在不会就可以说下想法就好，绝对不可以说不知道。

### 面试建议：

- 1.选一个自己相对比较擅长的领域。（源码深入）
- 2.基础要背（灵活背）
- 3.试着去了解这个领域市面上的技术。
- 4.如果有时间 研究其中一个众所周知的库的源码。




## 一、基本概念

### Android 四大组件是什么

- **Activity 活动 :**

Activity用于显示界面，它上面可以显示控件、监听控件并处理用户的事件做出响应。

- **Service 服务：**

是Android 中实现程序后台运行的解决方案，适合不需要和用户交互而且还要求长期运行的任务。依赖于创建服务的程序，程序被杀掉，服务也停止运行。服务不会自动开启线程，需要服务内部创建子线程。

- **Broadcast Receiver 广播接收器:**

应用程序可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个 Activity 或 Serice 来响应它们收到的信息，或者用NotificationManager 来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等。

- **Content Provider内容提供者 :**

内容提供器主要用于在不同的应用程序之间实现数据共享的功能，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据的安全性。

### Android平台的framework的层次结构？

- Linux Kernel(**Linux内核**)
- Hardware Abstraction Layer(**硬件抽象层**)
- Libraies(**系统运行库**或者是c/c++**核心库**)
- Application Framework(**开发框架包** )
- Applications(**核心应用程序**)

### 请介绍下Android中常用的布局。

答：常用四种布局方式，分别是：FrameLayout（帧布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局）。

（1）**FrameLayout**：所有东西依次都放在左上角，会重叠，这个布局比较简单，也只能放一点比较简单的东西。

（2）**LinearLayout**：线性布局，每一个LinearLayout里面又可分为垂直布局（android:orientation="vertical"）和水平布局（android:orientation="horizontal" ）。当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。

（3）**AbsoluteLayout**：绝对布局用X,Y坐标来指定元素的位置，这种布局方式也比较简单，但是在屏幕旋转时，往往会出问题，而且多个元素的时候，计算比较麻烦。

（4）**RelativeLayout**：相对布局可以理解为某一个元素为参照物，来定位的布局方式。主要属性有：相对于某一个元素android:layout_below、 android:layout_toLeftOf相对于父元素的地方android:layout_alignParentLeft、android:layout_alignParentRigh；

### 动画有哪几类，它们的特点和区别是什么

**(1) 视图动画**：定义了透明度、平移、缩放、旋转动画。实现原理：是每次绘画视图时，View 所在的 ViewGroup 中的 drawChild 函数获取该 View 的 Animation 的 Transformation 值，然后调用 canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧。缺点：是不具备交互性，当某个元素发生 View 动画后，其响应事件的位置仍然在动画前的地方。

**(2) 属性动画**：在一定时间间隔内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果，响应点击事件的有效区域也会发生改变。比较常用的几个动画类是：**ValueAnimator**(注重过程)、**ObjectAnimator**(具体操作) 和 **AnimatorSet**(组合)，其中 ObjectAnimator 继承自 ValueAnimator，AnimatorSet 是动画集合。

### Drawable

### Android 中有哪几种解析 xml的类？官方推荐哪种？以及它们的原理和区别。

Android 提供了三种解析XML的方式：**SAX(Simple API XML)** , **DOM(Document Object Model)**, **Pull解析** 

**SAX解析方式**：(Simple API for XML)解析器是一种基于事件的解析器，事件驱动的流式解析方式是，从文件的开始顺序解析到文档的结束，不可暂停或倒退。 

**Pull解析方式**：







## 二、Activity 面试详解

### 1、Activity的四种状态：

- **running**：处于活动状态，用户可以点击屏幕，屏幕会做出响应，处于Activity 的栈顶。
- **paused**：处于失去焦点状态或者被一个非全屏的Activity占据，又或者被一个透明的Activity放置栈顶。Activity只是失去和用户的交互能力，处于内存紧张状态。
- **stopped**：被另外的 Activity 全屏覆盖，不再是可见的，
- **killed**：Activity 已经被系统回收掉了。

### 2、Activity 在各种情况下的生命周期：

- **Activity启动** ：onCreate()初始化 -> onstart()可见了 -> onResume()可交互了
- **锁屏或Home键或新覆盖**： onPause() -> onStop()有可能被杀掉
- **解锁或回到前台**：onRestart()重新启动 -> onStart() -> onResume() 
- **退出 或Back键** ：onPause() -> onStop() -> onDestroy()回收，资源释放。
- **弹出对话框**：不会执行任何生命周期(注：对话框如果是Activity(Theme为Dialog)，还是会执行生命周期的)
- **从A跳转到B**：当B的主题为透明时，A只会执行onPause（A-onPause->B-(onCreate->onStart->onResume)）
- **从A跳转到B**：A-onPause->B-(onCreate->onStart->onResume)-A-onStop  (注意是B执行onResume后，A才执行onStop，所以尽量不要在onPause中做耗时操作)
- **从B返回到A**：B-onPause->A-(onRestart->onStart->onResume)-B-(onStop->onDestroy)

### 3、Activity之间的通信方式

- 1)在Intent跳转时携带数据 
- 2)借助类的静态变量
- 3)借助全局变量/Application
- 4)借助外部存储来实现通讯
  - 借助SharedPreference 
  - 使用Android数据库SQLite 
  - 赤裸裸的使用File 
- 5)借助Service

### 4、Activity上有 Dialog 的时候按Home键时的生命周期

**生命周期是**：onCreate() -> onStart() -> onResume -> 启动Dialog-> home键 -> onPause() -> onStop() 

 其实就是一个很正常的 Activity 生命周期，并没有什么特别的地方，但是注意 onPause 方法和 onStop 方法是在我点击 Home 键之后才有的，这就说明对话框的出现并没有使 Activity 进入后台。而是点击Home键才使Activity进入后台工作。AlertDialog对话框实际上是Activity的一个组件。

### 5、横竖屏切换时Activity的生命周期，如何将横竖屏切换对应的影响降至最低？

1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。

2、设置Activity的android:configChanges="orientation"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次。

3、设置 Activity的 android:configChanges="orientation  |  keyboardHidden" 时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged 方法。

### 6、Activity与Fragment之间生命周期比较

- Activity——onCreate->onStart->onResume->onPause->onStop->onDestroy
- Fragment——onAttach->onCreate->onCreateView->onActivityCreated->onStart->onResume ->onPause->onStop->onDestroyView->  onDestroy->onDetach

### 7、Activity 进程优先级

- **前台**：处于与用户交互的 Activity，或者在前台绑定的 Service。
- **可见**：处于前台，但用户又不能点击的情况下。
- **服务**：在后台开启 Service服务。
- **后台**：用户按了Home键回到了桌面，根据内存情况作出相应的回收。
- **空**：优先级最低，处于缓存的目的而保留，系统随时杀掉。

### 8、Activity 启动模式

- **standard**：标准模式，这也是系统的默认模式。每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在；

- **singleTop**：栈顶复用模式。(1) 如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的**onNewIntent**方法会被回调。(2) 需要注意的是，这个Activity的onCreate、onStart不会被系统调用，因为它并没有发生改变。(3) 如果新的Activity的实例已经存在但不是位于栈顶，那么新的Activity仍然会重新创建；

- **singleTask**：栈内复用模式。这是一种单实例模式，在这种情况下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewIntent；

- **singleInstance**：单实例模式，这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中。

### 9、scheme 跳转协议

是一种页面跳转协议，是一种非常好的实现机制，通过定义自己的scheme协议，可以非常方便跳转app的各个页面；通过scheme 协议，服务器可以定制化告诉App跳转哪个页面，可以通过通知栏消息定制化跳转页面，可以通过H5页面跳转页面。

- 1.服务端下发url，客户端根据url跳转到相应的页面。
- 2.H5跳转到App相应的Activity。
- 3.App根据url跳转到另一个App指定页面。

### 10、Activity状态保存于恢复

在《第一行代码》的 63 页中有详细介绍：
Activity中提供了一个onSaveInstanceState()回调方法，只要在代码中将临时数据保存在Bundle类型中，在Activity的onCreate方法中去获取数据即可。

### 快速退出所有Activity(关闭多个Activity)？

只需要用一个专门的收集类对所有的活动进行管理就可以了，在《第一行代码》的72页中有详细介绍：

新建ActivityCollector类作为活动管理器。









## 三、Fragment面试详解

碎片是一种可以嵌入在Activity当中的UI片段，它能让程序更加合理和充分地利用在大屏幕的空间，因而在平板上应用非常广泛，是Android自3.0版本开始引入的。

### Fragment 为什么被称为 第五大组件

(1) 首先在使用频率上，Fragment是不属于四大组件的范畴，他有自己的生命周期。
(2) 同时它可以灵活动态加载到 Activity 当中去。
(3 )而且 Fragment 并不像 Activity 那样独立的，虽然有自己的生命周期，但需要依附Activity。

### Fragment 加载到Activity的两种方式

- **静态加载**：作为XML标签添加到 Activity 的布局文件当中。(过程省略...)
- **动态加载**：动态在 Activity 中添加 Fragment 。 (常用)

```java
//前提1：先创建 Fragment1.java，并继承 Fragment，在onCreatview中初始化fragment的XML布局文件
//前提2：在Fragment1的XML布局文件中准备好容器R.id.lin_id

//步骤1：添加FragmentTransaction的实例
FragmentManager fragmentManager = getFragmentManager();
FragmentTransaction transaction = fragmentManager.beginTransaction();
//步骤2:用add()加Fragment对象fragment1，并绑定到其XML页面里的容器内
Fragment1 fragment1 = new Fragment1();
transaction.add(R.id.lin_id, fragment1, "fragment1");
//步骤3：调用commit方法使得FragmentTransaction实例的改变生效
transaction.commit();
```

### FragmentPagerAdapter 与 FragmentStatePagerAdaper 区别：

**FragmentPagerAdapter** ：FragmentPagerAdapter 在切换 ViewPager 的时候，只是把 Fragment的UI 与 Activity的UI 脱离开来，并不回收内存。所以它适用页面**减少**的情况。(在其源码 DestroyItem 方法中的最后一行，mCurTransaction.**detach** 可知)

**FragmentStatePagerAdaper** ：由于 FragmentStatePagerAdaper 在每次切换 ViewPager 的时候，它是回收内存的。又因为在页面较多的情况下会更耗内存，所以它适合页面**较多**的情况。(在源码 DestroyItem 方法中的最后一行，mCurTransaction.**remove** 可知 )

### Fragment 的生命周期

**onAttach**:表示在 Fragment 与 Activity 关联之后所回调的。

**onCreate**:表示初次创建 Fragment 的时候调用。(仅用来创建，但为完成)

**onCreateView**:系统在 Fragment 的首次**绘制**用户界面的时候调用。

**onViewCreated**:表示 Fragment 的UI界面已经绘制好了，可以初始化里面的控件资源。

*Activity - onCreate*:初始化Activity 的布局和数据之类。

**onActivityCreated**:在 Activity - onCreate()调用完成后才可以被调用，表示Activity被渲染绘制成功以后的调用方法。

*Activity - onStart*:表明 Activity 可见了。

**onStart**:表明 Fragment 也可见了。

*Activity - onResume*:表示 Activity 可以和用户交互了。

**onResume**:表示 Fragment 也可以和用户交互了。

  ↑  (到此为止已经完成了 Fragment 从启动到展现的操作。)

  ↓ (回退Fragment)

**onPause**: Fragment 无法和用户交互。

*Activity - onPause*:整个Activity 也无法和用户交互。

**onStop**:做一些相应的保存与释放。

*Activity - onStop*:做一些相应的保存与释放。

**onDestroyView**:对应创建的onCreateView，表示 Fragment 即将结束，然后会被保存。

**onDestroy**:表示 Fragment 不再被使用。

**onDetach**: Fragment 的最后一个方法，Fragment不再被使用。

*Activity - onDetach*:整个Activity被回收了。

简单的Fragment流程图—— onAttach->onCreate -> onCreateView -> onActivityCreated -> onStart -> onResume  ->创建成功-> onPause->onStop->onDestroyView -> onDestroy->onDetach

### Fragment 之间的通信  (课后复习)

- 在 Fragment 中调用 Activity 中的 **getActivity** 方法；
- 在 Activity(实现) 中调用 Fragment(创建接口) 中的方法 **接口回调；**
- 在 Fragment 中调用 Fragment 中的 **findFragmentById** 方法；

### Fragment 的 replace、add、remove 方法

- **replace** 是 FragmentManager 的方法，是将 Activity 最上层的 Fragment **替换**掉。
- **add** 将 Fragment 的实例添加到 Activity 的**最上层**；
- **remove** 将 Fragment 的实例从 Activity 的队列中**删除**；

### Fragment 管理器 FragmentManager
### fragment各种情况下的生命周期
### Fragment状态保存 startActivityForResult 是哪个类的方法，在什么情况下使用？

### 如何实现Fragment的滑动？
ViewPager + Fragment
### fragment之间传递数据的方式？

### Fragment 特点

- Fragment 可以作为 Activity 界面的一部分组成出现；
- 可以在一个 Activity 中同时出现多个 Fragment，并且一个 Fragment 也可以在多个 Activity 中使用；
- 在 Activity 运行过程中，可以添加、移除或者替换 Fragment；
- Fragment 可以响应自己的输入事件，并且有自己的生命周期，它们的生命周期会受宿主 Activity 的生命周期影响。
- Fragment 可以轻松得创建动态灵活的 UI 设计，可以适应于不同的屏幕尺寸。从手机到平板电脑。
- Fragment 解决 Activity 间的切换不流畅，轻量切换。
- Fragment 替代 TabActivity 做导航，性能更好。
- Fragment 做局部内容更新更方便，原来为了达到这一点要把多个布局放到一个 activity 里面，现在可以用多 Fragment 来代替，只有在需要的时候才加载 Fragment，提高性能。

### Fragment嵌套多个Fragment会出现bug吗？

参考：http://blog.csdn.net/megatronkings/article/details/51417510

### 怎么理解Activity和Fragment的关系？

- Fragment 拥有和 Activity 一致的生命周期，它和 Activity 一样被定义为 Controller 层的类。有过中大型项目开发经验的开发者，应该都会遇到过 Activity 过于臃肿的情况，而 Fragment 的出现就是为了缓解这一状况，可以说 它将屏幕分解为多个「Fragment（碎片）」（这句话很重要），但它又不同于 View，它干的实质上就是 Activity 的事情，负责控制 View 以及它们之间的逻辑。
- 将屏幕碎片化为多个 Fragment 后，其实 Activity 只需要花精力去管理当前屏幕内应该显示哪些 Fragments，以及应该对它们进行如何布局就行了。这是一种组件化的思维，用 Fragment 去组合了一系列有关联的 UI 组件，并管理它们之间的逻辑，而 Activity 负责在不同屏幕下（例如横竖屏）布局不同的 Fragments 组合。
- 这种碎片不单单能管理可视的 Views，它也能执行不可视的 Tasks，它提供了 retainInstance 属性，能够在 Activity 因为屏幕状态发生改变（例如切换横竖屏时）而销毁重建时，依然保留实例。这示意着我们能在 RetainedFragment 里面执行一些在屏幕状态发生改变时不被中断的操作。例如使用 RetainedFragment 来缓存在线音乐文件，它在横竖屏切换时依然维持下载进度，并通过一个 DialogFragment 来展示进度。


## 三、Service面试详解
### Service 是什么？

Service 是一种可以在后台执行长时间运行操作而没有用户界面的应用组件。(Service 不能做耗时操作)

### Service 和 BroadcastReceiver 共同点

都是运行在主线程当中，都不能做长时间的耗时操作。

### Service 和 Thread 的区别
- 定义: 

Thread 是程序执行的最小单元，它是分配CPU的最小单位。可以执行异步操作，是相对**独立**的。
Service 是Android的一种特殊机制，Service是运行在主线程当中的，是**依托于**所在的主线程。是由系统进程托管，也是一种轻量级IPC通信方式(Activity 和 Service 绑定，然后数据通信，并处于不同进程。 )

- 关系:

Service 和 Thread 之间并没有什么关联，Service 翻译成中文是服务，同时服务可以理解为后台。Thread 是开启子线程执行耗时操作，而 Service 是在主线程中执行，但总被认为可以在后台处理耗时任务，容易混淆了两者之间的概念。

- 实际开发中:

在Android系统当中，线程一般指的是工作线程，主线程主要负责UI绘制，而Service 就是运行在主线程当中的。

- 应用场景

当需要耗时的操作，比如网络请求，图片加载等等都应该使用工作线程。
当需要在后台播放音乐、开启定位、数据统计等等应该使用Service。

- 区分

1.不要把后台和子线程联系在一起；
2.服务和后台是不同的概念；
3.Android的后台是指它的运行不依赖与UI线程，即使程序被销毁了、程序被关闭了，服务进程仍然在后台进行计算、统计等等。
4.如果在 Service 执行耗时，也需要创建子线程，然后去做耗时逻辑。
5.Service是为了弥补 Activity 被销毁之后，无法获取之前所创建的子线程实例，并对后台进行控制的情况而产生的。

### 开启 Service 的两种方式以及区别

- **StartService**

1.定义一个类继承 Service
2.在Manifest.xml文件中配置该 Service
3.使用Context的startService(Intent)方法启动Service
4.不再使用时，调用 stopService(Intent) 方法停止该服务。

onBind
onCreated
onStartCommand：
onDestroy：不再使用服务，资源回收。

- **bindService**:

绑定服务提供了客户端和服务端接口，进行数据的交互(发送请求、获取结果、进程间通信)
1.创建BindService服务端，继承自Service，并在类中创建一个实例IBinder接口实现对象并提供公共方法给客户端调用。
2.从onBind()回调方法返回此Binder实例
3.在客户端中，从onServiceConnected()回调方法接收Binder，并使用提供的方法调用绑定服务。


### Service 的生命周期

**StartService** ：onCreat -> onStartCommand -> running -> stopService/stopSelf -> onDestroy

如果这个服务之前没有创建过，onCreate方法会先于 onStartCommand 方法执行，服务启动后一直保持运行状态，直到 stopService 或 stopSelf() 方法被调用。

**bindService**：onCreat -> onBind ->onUnBind -> onDestroy

如果这个服务之前没有创建过，onCreate方法会先于 onBind 方法执行，服务启动后一直保持运行状态，直到 unBindService 方法被调用。

**StartService+bindService**：同时被调用的情况下，需要同时调用 stopService和unBindService。




### Activity 怎么和 Service 绑定？
### 怎么在Activity 中启动自己对应的Service？
### service 和 activity 怎么进行数据交互？




## 四、Content Provider
### 谈谈你对ContentProvider的理解
### 说说ContentProvider、ContentResolver、ContentObserver 之间的关系


## 五、Broadcast Receiver
### 广播的定义

在Android 中，Broadcast 是一种广泛运用的在应用程序之间传输信息的机制，Android 中我们要发送的广播内容是一个Intent，这个Intent中可以携带我们要传送的数据。

广播实现了不同程序之间的**信息传输与共享**，只要和发送广播的action相同的接收者，都能接收到这个广播。还可以作为**通知**的作用，发送消息给service来更新UI。

类似设计模式中的“观察者模式”，当被观察者数据发生变化的时候，会去相应的通知观察者做相应的数据处理。

### 广播的场景

- 同一个App具有多个进程的不同组件之间的消息通信。
- 不同App之间的组件之间消息通信。

### 广播的种类

- **标准广播 Normal Broadcast **：一种完全异步执行的广播，所有接受者在同一时刻收到这条广播消息。效率高，没有先后顺序，无法截断。
- **有序广播 Ordered Broadcast**：一种同步执行的广播，同一时刻只会有一个广播接收器能够接收到这条广播消息。先后顺序，优先级，可截断。

### 实现广播 receiver

- **静态注册** : 将广播写在 AndroidMainifest.xml 文件当中，特点是:Activity 销毁了或进程被杀死了，仍然能接收广播。**注册完成就一直运行**
- **动态注册** : 在代码中调用 registerReceiver() 注册来进行广播的注册。必须在onDestroy中调用unregisterReceiver()方法，否则会引起内存泄露。**生命周期是跟随Activity的生命周期**

### 广播实现机制
### LocalBroadcastManager详解
### 请描述一下广播Broadcast Receiver的理解
### 广播的分类
### 广播使用的方式和场景
### 在manifest 和代码中如何注册和使用BroadcastReceiver?
### 本地广播和全局广播有什么差别？
### BroadcastReceiver，LocalBroadcastReceiver 区别



### Android中数据存储方式

Android中有5种数据存储方式，分别为文件存储、SQLite数据库、SharedPreferences、ContentProvider、网络。每种存储方式的特点如下：

- 1）**文件存储**：文件存储方式是一种较常用的方法，在Android中读取/写入文件的方法，与Java中实现I/O的程序是完全一样的，提供openFileInput()和openFileOutput()方法来读取设备上的文件。
- 2）**SQLite数据库**：SQLite是Android所集成的一个轻量级的嵌入式数据库，它不仅可以使用Andorid API操作，同时它也支持SQL语句进行增删改查等操作。
- 3）**SharedPreferences**：是Android提供的用于存储一些简单配置信息的一种机制，采用了XML格式将数据存储到设备中。不仅可以在同一个包下使用，还可以访问其他应用程序的数据，但是由于SharedPreferences的局限性，在实际操作中很少用来读取其他应用程序的数据。
- 4）**ContentProvider**：主要用于不同应用程序之间共享数据，ContentProvider更好的提供了数据共享接口的统一性，使不同应用共享数据更规范和安全。
- 5）**网络存储数据**：通过网络上提供的存储空间来上传(存储)或下载(获取)我们存储在网络空间中的数据信息

### 共享数据的方式
1.File， 2.Sqlite，3.Content Provider，4.Service，5.Broadcast Receiver，6.Intent

### Binder

**Binder** 是Android系统进程间通信（IPC）方式之一。Linux已经拥有的进程间通信IPC手段包括(Internet Process Connection)： 管道（Pipe）、信号（Signal）和跟踪（Trace）、插口（Socket）、报文队列（Message）、共享内存（Share Memory）和信号量（Semaphore）。本文详细介绍Binder作为Android主要IPC方式的优势。

### ART、Dalvik和JVM的关系及区别是什么？

- **ART** 就是 Android Runtime ，是安卓4.4之后的系统的新的虚拟机模式，改模式提升了运行效率，启用该模式之后，系统在安装APP的时候，会进行一次预编译，把代码转成机器语言存储在本地，这样运行的时候效率就高了。

- **Dalvik** 是一种安卓系统在上面运行的虚拟机，因为安卓系统是以Linux 为底层构建的，为了更加高效的适配到各种不同的硬件设备上面，就创建了这个Dalvik 虚拟机，该虚拟机可以将程序的语言由java转成机器语言二进制运行，然而每次开启运用的时候都会执行一次编译，所以效率不是很高，所以我们需要ART，增加效率。

- **JVM** 是 java虚拟机，是实现java夸平台的主要方式，可以使得java这样的高级语言编译成机器可以识别的机器语言，这样使得java 一次编译，到处运行。


### Handler机制原理

### ANR

**什么是ANR**： 在Android中，如果应用程序有一段时间响应不够灵敏，系统会向用户显示**应用程序无响应**（ANR：Application Not Responding）对话框。用户可以选择让程序继续运行或者关闭程序。

**ANR产生的原因**：ANR产生的根本原因是APP阻塞了UI线程，不同的组件发生ANR 的时间不一样，主线程 Activity 是 5 秒，Service是 20 秒，BroadCastReceiver 是 10 秒。AsyncTask是5秒，Handler也是5秒。

**怎样避免ANR**：让耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理。


### Java GC 原理

**(1)GC 垃圾回收机制**(Gabage Collection) 在jvm运行时，由于所需要存放的对象越来越多，java堆就得想办法回收已不再用的对象来节省空间，那么垃圾回收机制在进行垃圾回收前就得判断哪些实例已不再使用，哪些实例还要使用，以便于回收不再使用的实例。

**(2)判断对象是否已死**：jvm在回收垃圾之前，得先判断哪些实例是不再需要的，不能乱回收。

- 引用计数算法
- 可达性分析算法

**(3)垃圾收集算法**：

- **标记--清除算法**：先标记再清除，当对象被统一标记后，再统一回收。

- **复制算法**：把内存按容量分为两个相同的块。每次只使用其中的一块，当一块用完后，就将存活的对象复制到另一块，然后再清理已使用的空间。

- **标记--整理算法**：标记--整理算法的思想和标记--清除算法类似。但后续步骤不是清除可回收的对象，而是把存活的对象都向一端移动，然后直接清除掉边界以外的内存。

- **分代收集算法**：根据对象存活的情况不同，把内存分为新生代和年老代，新生代对象存活率低，就用复制算法，年老代存活率高，就用标记--清除算法或者标记--整理算法。


### OOM原理

**1、什么是OOM**：当 JVM 因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个异常。

**2、为什么会OOM**：

- **(1)瞬时加载了一些资源**，例如，视频、图片、音频等等的内存申请大小超过了App的额定内存值，解决方案：对资源可能需要申请大内存的地方做压缩处理。

- **(2)调用registerRecevier() 后未调用 unregisterReceiver()**, 解决方案：在每一次动态注册的时候，记得在在适当的地方（Activity的OnDestory()）取消注册。

- **(3)数据库cursor没有关闭**，解决方案：使用完cursor及时关闭。

- **(4)构造Adapter没有使用缓存contentview**， 解决方案：在构造Adapter的时候，使用ContentView缓存页面，节省内存。

- **(5)未关闭InputStream/OutputStream** , 解决方案：在使用到IO Stream 的时候，及时关闭。

- **(6)Bitmap使用后未调用recycle() **，解决方案：在Bitmap不在需要被加载到内存中的收获，做回收处理。

- **(7)Context泄露，内部类持有外部类的引用。** 解决方案：  第一： 将线程的内部类，改为静态内部类  第二：在线程内部采用弱引用保存Context引用。

- **(8)static 原因**。 解决方案： 

第一，应该尽量避免static成员变量引用资源耗费过多的实例，比如Context。

第二、Context尽量使用Application Context，因为Application的Context的生命周期比较长，引用它不会出现内存泄露的问题。

第三、使用WeakReference代替强引用。比如可以使用WeakReference<Context> mContextRef;

**3、为什么Android会有APP的内存限制**：

- **(1)要开发者使用内存更加合理。**限制每个应用可用内存上限，避免恶意程序或单个程序使用过多内存导致其他程序的不可运行。有了限制，开发者就必须合理使用资源，优化资源使用

- **(2)屏幕显示内容有限，内存足够即可**。即使有万千图片千万数据需要使用到，但在特定时刻需要展示给用户看的总是有限的，因为屏幕显示就那么大，上面可以放的信息就是很有限的。大部分信息都是处于准备显示状态，所以没必要给予太多heap内存。必须一个ListView显示图片，打个比方这个ListView含有500个item，但是屏幕显示最多有10调item显示，其余数据是处于准备显示状态。

- **(3)Android多个虚拟机Davlik的限制需要。**android设备上的APP运行，每打开一个应用就会打开至少一个独立虚拟机。这样可以避免系统崩溃，但代价是浪费更多内存。






### Volley
### RxJava+ Retrofit+okhttp

现在Android 市面上很火的当然是 Retrofit＋RxJava + OkHttp, 功能强大，简单易用。

- **Retrofit**：是 Square 公司开发的一款正对Android 网络请求的框架。底层基于OkHttp 实现。负责请求的数据和请求的结果，使用接口的方式呈现。

- **OkHttp**: 负责请求的过程。

- **RxJava**：负责异步，各种线程之间的切换。

### RxJava

> http://gank.io/post/560e15be2dca930e00da1083

- RxJava 的异步实现，是通过一种扩展的观察者模式来实现的。

- RxJava 的基本实现主要有三点：
1) 创建 Observer 观察者(或subscriber)，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式：onNext、onCompleted、onError。

2) 创建 Observable 被观察者，它决定什么时候触发事件以及触发怎样的事件。RxJava 使用 create() 、just()、from()方法来创建一个 Observable ，并为它定义事件触发规则。

3) Subscribe 订阅：创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单。observable.subscribe(observer);

### Retrofit


使用过程：第一步：

- 通过Builer构造者来创建 Retrofit 对象。
- 然后通过baseUrl来拼接URL(这里的URL不是完整的URL)。
- 通过.build()来完成对象的创建。

使用过程：第二步：

- 通过 Retrofit.create()方法创建好我们需要的网络请求接口。 
- 然后用 网络请求接口 调用他的方法contributorsBySimpleGetCall 来获取 Retrofit.call方法(其实他的底层也是用okhttp封装的)。
- 最后通过call.enqueue这个异步方法进行异步网络请求操作。

(都用接口的形式，做好了的封装。)

Retrofit源码剖析-动态代理：
1首先，通过method把它转换成 ServiceMethod；
2然后，通过 ServiceMethod，args 获取到okHttpCall对象；
3最后，再把okHttpCall进一步封装并返回call对象。 	






### Okhttp 原理

使用过程：

第一步：创建 **OKHttpClient** 的实例，
OkHttpClient client = new OkHttpClient()；

第二步：创建 **Request** 对象，封装了一些请求报文的信息。
Request request = new Request.Builder()
 .url("http://www.baidu.com")
 .build();

第三步：调用OkHttpClient的newCall方法创建一个 **call** 对象，并调用它的execute()/enqueue() 同步/异步来发送请求并获取服务器返回的数据。

**同步**获取数据：
Response response = client.newcall(request).execute();

**异步**获取数据：
 client.newcall(request).enqueue(new Callback){
onFailure()//失败
onResponse()//成功
}

### Butterknife

解决令人头疼的findViewById。

其实就是一个依托 **Java 的注解机制**来实现的辅助代码生成的框架。

使用简介：

1：绑定一个view(view不能为private 或者 stateic)
@BindView(R.id.mTxt)
Textview mTxt;

2：给一个View添加点击事件
@OnClick(R.id.mTxt)
public void onClick(){
  Toast...
}

3：给多个View添加点击事件：
@OnClick( { R.id.mTxt，R.id.Imageview } )
public void onClick(){
  Toast...
}

4.给ListView setItemClickListener
@OnItemClick(R.id.mListView)
public void onItemClick(){
  Toast...
}





### Android UI适配
### xml json gson区别
### Android内存泄露及管理

内存泄露：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了。

内存溢出：申请的内存超出了JVM能提供的内存大小，此时称之为溢出。


### 设计模式

### MVC MVP 架构

> https://juejin.im/entry/56ebb4ad5bbb50004c440972

**MVC简介**：全名是Model View Controller，如图，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。

- M层处理数据，业务逻辑等；
- V层处理界面的显示结果；
- C层起到桥梁的作用，来控制V层和M层通信以此来达到分离视图显示和业务逻辑层。


**Android中的MVC**：Android中界面部分也采用了当前比较流行的MVC框架，在Android中：

- (V)一般采用XML文件进行界面的描述，这些XML可以理解为AndroidApp的View。使用的时候可以非常方便的引入。同时便于后期界面的修改。逻辑中与界面对应的id不变化则代码不用修改，大大增强了代码的可维护性。

- (C)Android的控制层的重任通常落在了众多的 Activity 的肩上。这句话也就暗含了不要在Activity中写代码，要通过 Activity 交割 Model 业务逻辑层处理，这样做的另外一个原因是 Android 中的 Actiivity 的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。

- (M)我们针对业务模型，建立的数据结构和相关的类，就可以理解为AndroidApp的Model，Model是与View无关，而与业务相关的。对数据库的操作、对网络等的操作都应该在Model里面处理，当然对业务计算等操作也是必须放在的该层的。




**MVP简介**：MVP从更早的MVC框架演变过来，与MVC有一定的相似性：Controller/Presenter 负责逻辑的处理，Model 提供数据，View负责显示。

 view < - - > Presenter < - - >Model

**MVP框架由3部分组成**：View负责显示，Presenter负责逻辑处理，Model提供数据。在MVP模式里通常包含3个要素（加上View interface是4个）：

- View：负责绘制UI元素、与用户进行交互(在Android中体现为Activity)

- Model：负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合)

- Presenter：作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。

- *View interface：需要 View 实现的接口，View 通过 View interface与Presenter进行交互，降低耦合，方便进行单元测试

**MVP的优点**：

- 1、模型与视图完全分离，我们可以修改视图而不影响模型；

- 2、可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部；

- 3、我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁；

- 4、如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）。

举个简单的例子，UI层通知逻辑层（Presenter）用户点击了一个Button，逻辑层（Presenter）自己决定应该用什么行为进行响应，该找哪个模型（Model）去做这件事，最后逻辑层（Presenter）将完成的结果更新到UI层。

### handler
https://blog.csdn.net/wzhworld/article/details/78337641
### AsyncTask




## 六、

### AlertDialog，popupWindow，Activity区别
### Application 和 Activity 的 Context 对象的区别
### Android属性动画特性
### 如何导入外部数据库?
### LinearLayout、RelativeLayout、FrameLayout的特性及对比，并介绍使用场景。
### 谈谈对接口与回调的理解
### 回调的原理
### 写一个回调demo
### 介绍下SurfView
### RecycleView的使用
### 序列化的作用，以及Android两种序列化的区别
### 差值器
### 估值器
### 如何理解Activity，View，Window三者之间的关系？
### 运行时权限 p245页
### Android优化
### ListView优化方法
### 如何统计ListView加载速度

## 内存泄露
https://www.jianshu.com/p/f35ca324c285

## 网络
https://www.jianshu.com/p/97f77927db0f

### Http包头
### Get和Post区别
### Cache-control字段的作用
### Http和Https的区别
### Https怎么加密的
### 10亿数据找到出现最多次数的数字
